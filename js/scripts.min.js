/*!
 * Rolling Stone HTML5 Project
 * @author Todd Motto
 * @version 1.0.0
 * Copyright 2013.
 */
// Borrowed from http://www.codechewing.com/library/check-for-css-transition-support-in-the-browser-with-javascript/
(function(){
  if( 'WebkitTransition' in document.body.style ||
    'MozTransition' in document.body.style ||
    'OTransition' in document.body.style ||
    'transition' in document.body.style
  ) {
    document.querySelector('html').className += " animation";
  }
})();
(function(a) {
    if(/android|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(ad|hone|od)|iris|kindle|lge |maemo|meego.+mobile|midp|mmp|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows (ce|phone)|xda|xiino|playbook|silk/i.test(a)
    ||
    /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(di|rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(a.substr(0,4)))
    {
        document.querySelector('html').className += " mobile";
    }
})(navigator.userAgent||navigator.vendor||window.opera);
// Borrowed from modernizr
(function(){
  var bool;
  if(('ontouchstart' in window) || window.DocumentTouch && document instanceof DocumentTouch) {
    bool = true;
  } else {
    bool = false;
  }
  if(bool) {
    document.querySelector('html').className += " touch";
  }
})();
/*!
 * jQuery Transit - CSS3 transitions and transformations
 * (c) 2011-2012 Rico Sta. Cruz <rico@ricostacruz.com>
 * MIT Licensed.
 *
 * http://ricostacruz.com/jquery.transit
 * http://github.com/rstacruz/jquery.transit
 */

(function($) {
  $.transit = {
    version: "0.9.9",

    // Map of $.css() keys to values for 'transitionProperty'.
    // See https://developer.mozilla.org/en/CSS/CSS_transitions#Properties_that_can_be_animated
    propertyMap: {
      marginLeft    : 'margin',
      marginRight   : 'margin',
      marginBottom  : 'margin',
      marginTop     : 'margin',
      paddingLeft   : 'padding',
      paddingRight  : 'padding',
      paddingBottom : 'padding',
      paddingTop    : 'padding'
    },

    // Will simply transition "instantly" if false
    enabled: true,

    // Set this to false if you don't want to use the transition end property.
    useTransitionEnd: false
  };

  var div = document.createElement('div');
  var support = {};

  // Helper function to get the proper vendor property name.
  // (`transition` => `WebkitTransition`)
  function getVendorPropertyName(prop) {
    // Handle unprefixed versions (FF16+, for example)
    if (prop in div.style) return prop;

    var prefixes = ['Moz', 'Webkit', 'O', 'ms'];
    var prop_ = prop.charAt(0).toUpperCase() + prop.substr(1);

    if (prop in div.style) { return prop; }

    for (var i=0; i<prefixes.length; ++i) {
      var vendorProp = prefixes[i] + prop_;
      if (vendorProp in div.style) { return vendorProp; }
    }
  }

  // Helper function to check if transform3D is supported.
  // Should return true for Webkits and Firefox 10+.
  function checkTransform3dSupport() {
    div.style[support.transform] = '';
    div.style[support.transform] = 'rotateY(90deg)';
    return div.style[support.transform] !== '';
  }

  var isChrome = navigator.userAgent.toLowerCase().indexOf('chrome') > -1;

  // Check for the browser's transitions support.
  support.transition      = getVendorPropertyName('transition');
  support.transitionDelay = getVendorPropertyName('transitionDelay');
  support.transform       = getVendorPropertyName('transform');
  support.transformOrigin = getVendorPropertyName('transformOrigin');
  support.transform3d     = checkTransform3dSupport();

  var eventNames = {
    'transition':       'transitionEnd',
    'MozTransition':    'transitionend',
    'OTransition':      'oTransitionEnd',
    'WebkitTransition': 'webkitTransitionEnd',
    'msTransition':     'MSTransitionEnd'
  };

  // Detect the 'transitionend' event needed.
  var transitionEnd = support.transitionEnd = eventNames[support.transition] || null;

  // Populate jQuery's `$.support` with the vendor prefixes we know.
  // As per [jQuery's cssHooks documentation](http://api.jquery.com/jQuery.cssHooks/),
  // we set $.support.transition to a string of the actual property name used.
  for (var key in support) {
    if (support.hasOwnProperty(key) && typeof $.support[key] === 'undefined') {
      $.support[key] = support[key];
    }
  }

  // Avoid memory leak in IE.
  div = null;

  // ## $.cssEase
  // List of easing aliases that you can use with `$.fn.transition`.
  $.cssEase = {
    '_default':       'ease',
    'in':             'ease-in',
    'out':            'ease-out',
    'in-out':         'ease-in-out',
    'snap':           'cubic-bezier(0,1,.5,1)',
    // Penner equations
    'easeOutCubic':   'cubic-bezier(.215,.61,.355,1)',
    'easeInOutCubic': 'cubic-bezier(.645,.045,.355,1)',
    'easeInCirc':     'cubic-bezier(.6,.04,.98,.335)',
    'easeOutCirc':    'cubic-bezier(.075,.82,.165,1)',
    'easeInOutCirc':  'cubic-bezier(.785,.135,.15,.86)',
    'easeInExpo':     'cubic-bezier(.95,.05,.795,.035)',
    'easeOutExpo':    'cubic-bezier(.19,1,.22,1)',
    'easeInOutExpo':  'cubic-bezier(1,0,0,1)',
    'easeInQuad':     'cubic-bezier(.55,.085,.68,.53)',
    'easeOutQuad':    'cubic-bezier(.25,.46,.45,.94)',
    'easeInOutQuad':  'cubic-bezier(.455,.03,.515,.955)',
    'easeInQuart':    'cubic-bezier(.895,.03,.685,.22)',
    'easeOutQuart':   'cubic-bezier(.165,.84,.44,1)',
    'easeInOutQuart': 'cubic-bezier(.77,0,.175,1)',
    'easeInQuint':    'cubic-bezier(.755,.05,.855,.06)',
    'easeOutQuint':   'cubic-bezier(.23,1,.32,1)',
    'easeInOutQuint': 'cubic-bezier(.86,0,.07,1)',
    'easeInSine':     'cubic-bezier(.47,0,.745,.715)',
    'easeOutSine':    'cubic-bezier(.39,.575,.565,1)',
    'easeInOutSine':  'cubic-bezier(.445,.05,.55,.95)',
    'easeInBack':     'cubic-bezier(.6,-.28,.735,.045)',
    'easeOutBack':    'cubic-bezier(.175, .885,.32,1.275)',
    'easeInOutBack':  'cubic-bezier(.68,-.55,.265,1.55)'
  };

  // ## 'transform' CSS hook
  // Allows you to use the `transform` property in CSS.
  //
  //     $("#hello").css({ transform: "rotate(90deg)" });
  //
  //     $("#hello").css('transform');
  //     //=> { rotate: '90deg' }
  //
  $.cssHooks['transit:transform'] = {
    // The getter returns a `Transform` object.
    get: function(elem) {
      return $(elem).data('transform') || new Transform();
    },

    // The setter accepts a `Transform` object or a string.
    set: function(elem, v) {
      var value = v;

      if (!(value instanceof Transform)) {
        value = new Transform(value);
      }

      // We've seen the 3D version of Scale() not work in Chrome when the
      // element being scaled extends outside of the viewport.  Thus, we're
      // forcing Chrome to not use the 3d transforms as well.  Not sure if
      // translate is affectede, but not risking it.  Detection code from
      // http://davidwalsh.name/detecting-google-chrome-javascript
      if (support.transform === 'WebkitTransform' && !isChrome) {
        elem.style[support.transform] = value.toString(true);
      } else {
        elem.style[support.transform] = value.toString();
      }

      $(elem).data('transform', value);
    }
  };

  // Add a CSS hook for `.css({ transform: '...' })`.
  // In jQuery 1.8+, this will intentionally override the default `transform`
  // CSS hook so it'll play well with Transit. (see issue #62)
  $.cssHooks.transform = {
    set: $.cssHooks['transit:transform'].set
  };

  // jQuery 1.8+ supports prefix-free transitions, so these polyfills will not
  // be necessary.
  if ($.fn.jquery < "1.8") {
    // ## 'transformOrigin' CSS hook
    // Allows the use for `transformOrigin` to define where scaling and rotation
    // is pivoted.
    //
    //     $("#hello").css({ transformOrigin: '0 0' });
    //
    $.cssHooks.transformOrigin = {
      get: function(elem) {
        return elem.style[support.transformOrigin];
      },
      set: function(elem, value) {
        elem.style[support.transformOrigin] = value;
      }
    };

    // ## 'transition' CSS hook
    // Allows you to use the `transition` property in CSS.
    //
    //     $("#hello").css({ transition: 'all 0 ease 0' });
    //
    $.cssHooks.transition = {
      get: function(elem) {
        return elem.style[support.transition];
      },
      set: function(elem, value) {
        elem.style[support.transition] = value;
      }
    };
  }

  // ## Other CSS hooks
  // Allows you to rotate, scale and translate.
  registerCssHook('scale');
  registerCssHook('translate');
  registerCssHook('rotate');
  registerCssHook('rotateX');
  registerCssHook('rotateY');
  registerCssHook('rotate3d');
  registerCssHook('perspective');
  registerCssHook('skewX');
  registerCssHook('skewY');
  registerCssHook('x', true);
  registerCssHook('y', true);

  // ## Transform class
  // This is the main class of a transformation property that powers
  // `$.fn.css({ transform: '...' })`.
  //
  // This is, in essence, a dictionary object with key/values as `-transform`
  // properties.
  //
  //     var t = new Transform("rotate(90) scale(4)");
  //
  //     t.rotate             //=> "90deg"
  //     t.scale              //=> "4,4"
  //
  // Setters are accounted for.
  //
  //     t.set('rotate', 4)
  //     t.rotate             //=> "4deg"
  //
  // Convert it to a CSS string using the `toString()` and `toString(true)` (for WebKit)
  // functions.
  //
  //     t.toString()         //=> "rotate(90deg) scale(4,4)"
  //     t.toString(true)     //=> "rotate(90deg) scale3d(4,4,0)" (WebKit version)
  //
  function Transform(str) {
    if (typeof str === 'string') { this.parse(str); }
    return this;
  }

  Transform.prototype = {
    // ### setFromString()
    // Sets a property from a string.
    //
    //     t.setFromString('scale', '2,4');
    //     // Same as set('scale', '2', '4');
    //
    setFromString: function(prop, val) {
      var args =
        (typeof val === 'string')  ? val.split(',') :
        (val.constructor === Array) ? val :
        [ val ];

      args.unshift(prop);

      Transform.prototype.set.apply(this, args);
    },

    // ### set()
    // Sets a property.
    //
    //     t.set('scale', 2, 4);
    //
    set: function(prop) {
      var args = Array.prototype.slice.apply(arguments, [1]);
      if (this.setter[prop]) {
        this.setter[prop].apply(this, args);
      } else {
        this[prop] = args.join(',');
      }
    },

    get: function(prop) {
      if (this.getter[prop]) {
        return this.getter[prop].apply(this);
      } else {
        return this[prop] || 0;
      }
    },

    setter: {
      // ### rotate
      //
      //     .css({ rotate: 30 })
      //     .css({ rotate: "30" })
      //     .css({ rotate: "30deg" })
      //     .css({ rotate: "30deg" })
      //
      rotate: function(theta) {
        this.rotate = unit(theta, 'deg');
      },

      rotateX: function(theta) {
        this.rotateX = unit(theta, 'deg');
      },

      rotateY: function(theta) {
        this.rotateY = unit(theta, 'deg');
      },

      // ### scale
      //
      //     .css({ scale: 9 })      //=> "scale(9,9)"
      //     .css({ scale: '3,2' })  //=> "scale(3,2)"
      //
      scale: function(x, y) {
        if (y === undefined) { y = x; }
        this.scale = x + "," + y;
      },

      // ### skewX + skewY
      skewX: function(x) {
        this.skewX = unit(x, 'deg');
      },

      skewY: function(y) {
        this.skewY = unit(y, 'deg');
      },

      // ### perspectvie
      perspective: function(dist) {
        this.perspective = unit(dist, 'px');
      },

      // ### x / y
      // Translations. Notice how this keeps the other value.
      //
      //     .css({ x: 4 })       //=> "translate(4px, 0)"
      //     .css({ y: 10 })      //=> "translate(4px, 10px)"
      //
      x: function(x) {
        this.set('translate', x, null);
      },

      y: function(y) {
        this.set('translate', null, y);
      },

      // ### translate
      // Notice how this keeps the other value.
      //
      //     .css({ translate: '2, 5' })    //=> "translate(2px, 5px)"
      //
      translate: function(x, y) {
        if (this._translateX === undefined) { this._translateX = 0; }
        if (this._translateY === undefined) { this._translateY = 0; }

        if (x !== null && x !== undefined) { this._translateX = unit(x, 'px'); }
        if (y !== null && y !== undefined) { this._translateY = unit(y, 'px'); }

        this.translate = this._translateX + "," + this._translateY;
      }
    },

    getter: {
      x: function() {
        return this._translateX || 0;
      },

      y: function() {
        return this._translateY || 0;
      },

      scale: function() {
        var s = (this.scale || "1,1").split(',');
        if (s[0]) { s[0] = parseFloat(s[0]); }
        if (s[1]) { s[1] = parseFloat(s[1]); }

        // "2.5,2.5" => 2.5
        // "2.5,1" => [2.5,1]
        return (s[0] === s[1]) ? s[0] : s;
      },

      rotate3d: function() {
        var s = (this.rotate3d || "0,0,0,0deg").split(',');
        for (var i=0; i<=3; ++i) {
          if (s[i]) { s[i] = parseFloat(s[i]); }
        }
        if (s[3]) { s[3] = unit(s[3], 'deg'); }

        return s;
      }
    },

    // ### parse()
    // Parses from a string. Called on constructor.
    parse: function(str) {
      var self = this;
      str.replace(/([a-zA-Z0-9]+)\((.*?)\)/g, function(x, prop, val) {
        self.setFromString(prop, val);
      });
    },

    // ### toString()
    // Converts to a `transition` CSS property string. If `use3d` is given,
    // it converts to a `-webkit-transition` CSS property string instead.
    toString: function(use3d) {
      var re = [];

      for (var i in this) {
        if (this.hasOwnProperty(i)) {
          // Don't use 3D transformations if the browser can't support it.
          if ((!support.transform3d) && (
            (i === 'rotateX') ||
            (i === 'rotateY') ||
            (i === 'perspective') ||
            (i === 'transformOrigin'))) { continue; }

          if (i[0] !== '_') {
            if (use3d && (i === 'scale')) {
              re.push(i + "3d(" + this[i] + ",1)");
            } else if (use3d && (i === 'translate')) {
              re.push(i + "3d(" + this[i] + ",0)");
            } else {
              re.push(i + "(" + this[i] + ")");
            }
          }
        }
      }

      return re.join(" ");
    }
  };

  function callOrQueue(self, queue, fn) {
    if (queue === true) {
      self.queue(fn);
    } else if (queue) {
      self.queue(queue, fn);
    } else {
      fn();
    }
  }

  // ### getProperties(dict)
  // Returns properties (for `transition-property`) for dictionary `props`. The
  // value of `props` is what you would expect in `$.css(...)`.
  function getProperties(props) {
    var re = [];

    $.each(props, function(key) {
      key = $.camelCase(key); // Convert "text-align" => "textAlign"
      key = $.transit.propertyMap[key] || $.cssProps[key] || key;
      key = uncamel(key); // Convert back to dasherized

      if ($.inArray(key, re) === -1) { re.push(key); }
    });

    return re;
  }

  // ### getTransition()
  // Returns the transition string to be used for the `transition` CSS property.
  //
  // Example:
  //
  //     getTransition({ opacity: 1, rotate: 30 }, 500, 'ease');
  //     //=> 'opacity 500ms ease, -webkit-transform 500ms ease'
  //
  function getTransition(properties, duration, easing, delay) {
    // Get the CSS properties needed.
    var props = getProperties(properties);

    // Account for aliases (`in` => `ease-in`).
    if ($.cssEase[easing]) { easing = $.cssEase[easing]; }

    // Build the duration/easing/delay attributes for it.
    var attribs = '' + toMS(duration) + ' ' + easing;
    if (parseInt(delay, 10) > 0) { attribs += ' ' + toMS(delay); }

    // For more properties, add them this way:
    // "margin 200ms ease, padding 200ms ease, ..."
    var transitions = [];
    $.each(props, function(i, name) {
      transitions.push(name + ' ' + attribs);
    });

    return transitions.join(', ');
  }

  // ## $.fn.transition
  // Works like $.fn.animate(), but uses CSS transitions.
  //
  //     $("...").transition({ opacity: 0.1, scale: 0.3 });
  //
  //     // Specific duration
  //     $("...").transition({ opacity: 0.1, scale: 0.3 }, 500);
  //
  //     // With duration and easing
  //     $("...").transition({ opacity: 0.1, scale: 0.3 }, 500, 'in');
  //
  //     // With callback
  //     $("...").transition({ opacity: 0.1, scale: 0.3 }, function() { ... });
  //
  //     // With everything
  //     $("...").transition({ opacity: 0.1, scale: 0.3 }, 500, 'in', function() { ... });
  //
  //     // Alternate syntax
  //     $("...").transition({
  //       opacity: 0.1,
  //       duration: 200,
  //       delay: 40,
  //       easing: 'in',
  //       complete: function() { /* ... */ }
  //      });
  //
  $.fn.transition = $.fn.transit = function(properties, duration, easing, callback) {
    var self  = this;
    var delay = 0;
    var queue = true;

    // Account for `.transition(properties, callback)`.
    if (typeof duration === 'function') {
      callback = duration;
      duration = undefined;
    }

    // Account for `.transition(properties, duration, callback)`.
    if (typeof easing === 'function') {
      callback = easing;
      easing = undefined;
    }

    // Alternate syntax.
    if (typeof properties.easing !== 'undefined') {
      easing = properties.easing;
      delete properties.easing;
    }

    if (typeof properties.duration !== 'undefined') {
      duration = properties.duration;
      delete properties.duration;
    }

    if (typeof properties.complete !== 'undefined') {
      callback = properties.complete;
      delete properties.complete;
    }

    if (typeof properties.queue !== 'undefined') {
      queue = properties.queue;
      delete properties.queue;
    }

    if (typeof properties.delay !== 'undefined') {
      delay = properties.delay;
      delete properties.delay;
    }

    // Set defaults. (`400` duration, `ease` easing)
    if (typeof duration === 'undefined') { duration = $.fx.speeds._default; }
    if (typeof easing === 'undefined')   { easing = $.cssEase._default; }

    duration = toMS(duration);

    // Build the `transition` property.
    var transitionValue = getTransition(properties, duration, easing, delay);

    // Compute delay until callback.
    // If this becomes 0, don't bother setting the transition property.
    var work = $.transit.enabled && support.transition;
    var i = work ? (parseInt(duration, 10) + parseInt(delay, 10)) : 0;

    // If there's nothing to do...
    if (i === 0) {
      var fn = function(next) {
        self.css(properties);
        if (callback) { callback.apply(self); }
        if (next) { next(); }
      };

      callOrQueue(self, queue, fn);
      return self;
    }

    // Save the old transitions of each element so we can restore it later.
    var oldTransitions = {};

    var run = function(nextCall) {
      var bound = false;

      // Prepare the callback.
      var cb = function() {
        if (bound) { self.unbind(transitionEnd, cb); }

        if (i > 0) {
          self.each(function() {
            this.style[support.transition] = (oldTransitions[this] || null);
          });
        }

        if (typeof callback === 'function') { callback.apply(self); }
        if (typeof nextCall === 'function') { nextCall(); }
      };

      if ((i > 0) && (transitionEnd) && ($.transit.useTransitionEnd)) {
        // Use the 'transitionend' event if it's available.
        bound = true;
        self.bind(transitionEnd, cb);
      } else {
        // Fallback to timers if the 'transitionend' event isn't supported.
        window.setTimeout(cb, i);
      }

      // Apply transitions.
      self.each(function() {
        if (i > 0) {
          this.style[support.transition] = transitionValue;
        }
        $(this).css(properties);
      });
    };

    // Defer running. This allows the browser to paint any pending CSS it hasn't
    // painted yet before doing the transitions.
    var deferredRun = function(next) {
        this.offsetWidth; // force a repaint
        run(next);
    };

    // Use jQuery's fx queue.
    callOrQueue(self, queue, deferredRun);

    // Chainability.
    return this;
  };

  function registerCssHook(prop, isPixels) {
    // For certain properties, the 'px' should not be implied.
    if (!isPixels) { $.cssNumber[prop] = true; }

    $.transit.propertyMap[prop] = support.transform;

    $.cssHooks[prop] = {
      get: function(elem) {
        var t = $(elem).css('transit:transform');
        return t.get(prop);
      },

      set: function(elem, value) {
        var t = $(elem).css('transit:transform');
        t.setFromString(prop, value);

        $(elem).css({ 'transit:transform': t });
      }
    };

  }

  // ### uncamel(str)
  // Converts a camelcase string to a dasherized string.
  // (`marginLeft` => `margin-left`)
  function uncamel(str) {
    return str.replace(/([A-Z])/g, function(letter) { return '-' + letter.toLowerCase(); });
  }

  // ### unit(number, unit)
  // Ensures that number `number` has a unit. If no unit is found, assume the
  // default is `unit`.
  //
  //     unit(2, 'px')          //=> "2px"
  //     unit("30deg", 'rad')   //=> "30deg"
  //
  function unit(i, units) {
    if ((typeof i === "string") && (!i.match(/^[\-0-9\.]+$/))) {
      return i;
    } else {
      return "" + i + units;
    }
  }

  // ### toMS(duration)
  // Converts given `duration` to a millisecond string.
  //
  //     toMS('fast')   //=> '400ms'
  //     toMS(10)       //=> '10ms'
  //
  function toMS(duration) {
    var i = duration;

    // Allow for string durations like 'fast'.
    if ($.fx.speeds[i]) { i = $.fx.speeds[i]; }

    return unit(i, 'ms');
  }

  // Export some functions for testable-ness.
  $.transit.getTransitionValue = getTransition;
})(jQuery);
window.requestAnimFrame = (function(){
 return  window.requestAnimationFrame       ||
         window.webkitRequestAnimationFrame ||
         window.mozRequestAnimationFrame    ||
         window.oRequestAnimationFrame      ||
         window.msRequestAnimationFrame     ||
         function(/* function */ callback, /* DOMElement */ element){
           window.setTimeout(callback, 1000 / 60);
         };
})();
function ProgressiveImageSequence( imgpath , count ,  options ) {
        var myself = this;

        var images = [];
        var numLoaded = 0;
        var isComplete = false;
        this.length = count;


        var defaultOptions = {
                indexSize: 4 ,
                initialStep: 64 ,
                onComplete: null ,
                onProgress: null ,
                stopAt: 1
        };
        var pref = {};
        $.extend(pref,defaultOptions,options);

        var step = pref.initialStep;
        var current = 0;
        var hasRestepped = false;

        function callback( f , o ) {
                if ( !!f ) f.apply(o);
        }

        this.stop = function() {
                step = pref.stopAt / 2;
        };

        this.reset = function() {
                isComplete = false;
                numLoaded = 0;
                step = pref.initialStep;
                current = 0;
                hasRestepped = false;
                this.nearestIndex = -1;
                $.each( images , function(k,v){
                        !!v && v.unload();
                });
        };

        this.getAt = function( index ) {
                return images[index].image;
        };

        this.nearestIndex = -1;

        this.getNearest = function( index ) {
                index = Math.floor(index);
                var diff = 0;
                var i,img;
                for ( diff = 0; diff <images.length ; diff++ ) {
                        i = index+diff;
                        if ( i>=0 && i<images.length) {
                                img = images[i];
                                if ( img && img.isLoaded() ) {
                                        this.nearestIndex = i;
                                        return img.image;
                                }
                        }
                        i = index-diff;
                        if ( i>=0 && i<images.length) {
                                img = images[i];
                                if ( img && img.isLoaded() ) {
                                        this.nearestIndex = i;
                                        return img.image;
                                }
                        }
                }
                return null;
        };




        // Loading

        this.getNumLoaded = function() {
                return numLoaded;
        };

        this.getLoadProgress = function() {
                return numLoaded * pref.stopAt / myself.length;
        };

        this.isLoaded = function(index) {
                if ( index === undefined ) {
                        return numLoaded == myself.length;
                } else {
                        return images[index].isLoaded();
                }
        };

        this.loadPosition = function( position , complete ) {
                position = Math.min( 1 , Math.max(0, position) );
                var index = position * (myself.length-1);

                console.log(myself.length);
                index = Math.round(index);
                myself.loadIndex(index, complete);
        };

        this.loadIndex = function(index, complete) {
                if ( index < 0 || index >= myself.length ) return false;

                if ( index != Math.floor(index) ) {
                        return false;
                }

                //console.log( "Loading " + index + " ("+[current,step]+")" );

                var img = images[index];
                if ( img == null ) {
                        var src = getSrcAt(index);
                        img = new ImageLoader(src);
                        images[index] = img;
                }
                img.load( function() {
                        numLoaded++;
                        if ( !isComplete ) {
                                callback(pref.onProgress,this);
                        } else {
                                //console && console.log("On progress?");
                        }
                        callback(complete,this);
                } );
        };

        this.loadNext = function(complete) {
                if ( step < pref.stopAt ) return; // in this case we've already loaded all images - other threads just don't know yet

                function next() {
                        loadNextImage();
                        callback(complete,this);
                }
                function end() {
                        finished();
                        callback(complete,this);
                }
                current+=step;
                if ( current >= myself.length ) {
                        if ( hasRestepped ) step /= 2;
                        hasRestepped = true;
                        current = step/2;
                        if ( current >= pref.stopAt ) {
                                myself.loadIndex(current,next);
                        } else {
                                finished();
                        }
                } else {
                        myself.loadIndex(current,next);
                }
        };

        this.getImageLoader = function(index) {
                return images[index];
        };

        function loadNextImage() {
                setTimeout( function(){ myself.loadNext(); } , 5 );
        }

        function finished() {
                isComplete = true;
                callback(pref.onComplete,this);
                console.log( "All images loaded" , numLoaded, 'of', myself.length );
        }


        function getSrcAt( index ) {
                var str = (index+1+Math.pow(10,pref.indexSize)).toString(10).substr(1);
                return imgpath.replace( '{index}' , str );
        }


        this.load = function() {
                myself.loadIndex(0,loadNextImage);
        }
}



function ImageLoader( src ) {
        //var elem = $('<img>');
        this.image = new Image();
        var img = this.image;
        var loadStarted = false;

        this.getSrc = function() {
                return src;
        };

        this.load = function(complete) {

                loadStarted = true;
                img.src = src;
                if ( img.complete ) {
                        complete.apply(img);
                } else {
                        $(img).load(complete);
                }
        };

        this.unload = function() {
                loadStarted = false;
                //img.src = '';
                img = this.image = new Image();
        };

        this.isLoaded = function() {
                return loadStarted && img.complete;
        }
}
(function(d){d.flexslider=function(j,l){var a=d(j),c=d.extend({},d.flexslider.defaults,l),e=c.namespace,q="ontouchstart"in window||window.DocumentTouch&&document instanceof DocumentTouch,u=q?"touchend":"click",m="vertical"===c.direction,n=c.reverse,h=0<c.itemWidth,s="fade"===c.animation,t=""!==c.asNavFor,f={};d.data(j,"flexslider",a);f={init:function(){a.animating=!1;a.currentSlide=c.startAt;a.animatingTo=a.currentSlide;a.atEnd=0===a.currentSlide||a.currentSlide===a.last;a.containerSelector=c.selector.substr(0,
c.selector.search(" "));a.slides=d(c.selector,a);a.container=d(a.containerSelector,a);a.count=a.slides.length;a.syncExists=0<d(c.sync).length;"slide"===c.animation&&(c.animation="swing");a.prop=m?"top":"marginLeft";a.args={};a.manualPause=!1;var b=a,g;if(g=!c.video)if(g=!s)if(g=c.useCSS)a:{g=document.createElement("div");var p=["perspectiveProperty","WebkitPerspective","MozPerspective","OPerspective","msPerspective"],e;for(e in p)if(void 0!==g.style[p[e]]){a.pfx=p[e].replace("Perspective","").toLowerCase();
a.prop="-"+a.pfx+"-transform";g=!0;break a}g=!1}b.transitions=g;""!==c.controlsContainer&&(a.controlsContainer=0<d(c.controlsContainer).length&&d(c.controlsContainer));""!==c.manualControls&&(a.manualControls=0<d(c.manualControls).length&&d(c.manualControls));c.randomize&&(a.slides.sort(function(){return Math.round(Math.random())-0.5}),a.container.empty().append(a.slides));a.doMath();t&&f.asNav.setup();a.setup("init");c.controlNav&&f.controlNav.setup();c.directionNav&&f.directionNav.setup();c.keyboard&&
(1===d(a.containerSelector).length||c.multipleKeyboard)&&d(document).bind("keyup",function(b){b=b.keyCode;if(!a.animating&&(39===b||37===b))b=39===b?a.getTarget("next"):37===b?a.getTarget("prev"):!1,a.flexAnimate(b,c.pauseOnAction)});c.mousewheel&&a.bind("mousewheel",function(b,g){b.preventDefault();var d=0>g?a.getTarget("next"):a.getTarget("prev");a.flexAnimate(d,c.pauseOnAction)});c.pausePlay&&f.pausePlay.setup();c.slideshow&&(c.pauseOnHover&&a.hover(function(){!a.manualPlay&&!a.manualPause&&a.pause()},
function(){!a.manualPause&&!a.manualPlay&&a.play()}),0<c.initDelay?setTimeout(a.play,c.initDelay):a.play());q&&c.touch&&f.touch();(!s||s&&c.smoothHeight)&&d(window).bind("resize focus",f.resize);setTimeout(function(){c.start(a)},200)},asNav:{setup:function(){a.asNav=!0;a.animatingTo=Math.floor(a.currentSlide/a.move);a.currentItem=a.currentSlide;a.slides.removeClass(e+"active-slide").eq(a.currentItem).addClass(e+"active-slide");a.slides.click(function(b){b.preventDefault();b=d(this);var g=b.index();
!d(c.asNavFor).data("flexslider").animating&&!b.hasClass("active")&&(a.direction=a.currentItem<g?"next":"prev",a.flexAnimate(g,c.pauseOnAction,!1,!0,!0))})}},controlNav:{setup:function(){a.manualControls?f.controlNav.setupManual():f.controlNav.setupPaging()},setupPaging:function(){var b=1,g;a.controlNavScaffold=d('<ol class="'+e+"control-nav "+e+("thumbnails"===c.controlNav?"control-thumbs":"control-paging")+'"></ol>');if(1<a.pagingCount)for(var p=0;p<a.pagingCount;p++)g="thumbnails"===c.controlNav?
'<img src="'+a.slides.eq(p).attr("data-thumb")+'"/>':"<a>"+b+"</a>",a.controlNavScaffold.append("<li>"+g+"</li>"),b++;a.controlsContainer?d(a.controlsContainer).append(a.controlNavScaffold):a.append(a.controlNavScaffold);f.controlNav.set();f.controlNav.active();a.controlNavScaffold.delegate("a, img",u,function(b){b.preventDefault();b=d(this);var g=a.controlNav.index(b);b.hasClass(e+"active")||(a.direction=g>a.currentSlide?"next":"prev",a.flexAnimate(g,c.pauseOnAction))});q&&a.controlNavScaffold.delegate("a",
"click touchstart",function(a){a.preventDefault()})},setupManual:function(){a.controlNav=a.manualControls;f.controlNav.active();a.controlNav.live(u,function(b){b.preventDefault();b=d(this);var g=a.controlNav.index(b);b.hasClass(e+"active")||(g>a.currentSlide?a.direction="next":a.direction="prev",a.flexAnimate(g,c.pauseOnAction))});q&&a.controlNav.live("click touchstart",function(a){a.preventDefault()})},set:function(){a.controlNav=d("."+e+"control-nav li "+("thumbnails"===c.controlNav?"img":"a"),
a.controlsContainer?a.controlsContainer:a)},active:function(){a.controlNav.removeClass(e+"active").eq(a.animatingTo).addClass(e+"active")},update:function(b,c){1<a.pagingCount&&"add"===b?a.controlNavScaffold.append(d("<li><a>"+a.count+"</a></li>")):1===a.pagingCount?a.controlNavScaffold.find("li").remove():a.controlNav.eq(c).closest("li").remove();f.controlNav.set();1<a.pagingCount&&a.pagingCount!==a.controlNav.length?a.update(c,b):f.controlNav.active()}},directionNav:{setup:function(){var b=d('<ul class="'+
e+'direction-nav"><li><a class="'+e+'prev" href="#">'+c.prevText+'</a></li><li><a class="'+e+'next" href="#">'+c.nextText+"</a></li></ul>");a.controlsContainer?(d(a.controlsContainer).append(b),a.directionNav=d("."+e+"direction-nav li a",a.controlsContainer)):(a.append(b),a.directionNav=d("."+e+"direction-nav li a",a));f.directionNav.update();a.directionNav.bind(u,function(b){b.preventDefault();b=d(this).hasClass(e+"next")?a.getTarget("next"):a.getTarget("prev");a.flexAnimate(b,c.pauseOnAction)});
q&&a.directionNav.bind("click touchstart",function(a){a.preventDefault()})},update:function(){var b=e+"disabled";1===a.pagingCount?a.directionNav.addClass(b):c.animationLoop?a.directionNav.removeClass(b):0===a.animatingTo?a.directionNav.removeClass(b).filter("."+e+"prev").addClass(b):a.animatingTo===a.last?a.directionNav.removeClass(b).filter("."+e+"next").addClass(b):a.directionNav.removeClass(b)}},pausePlay:{setup:function(){var b=d('<div class="'+e+'pauseplay"><a></a></div>');a.controlsContainer?
(a.controlsContainer.append(b),a.pausePlay=d("."+e+"pauseplay a",a.controlsContainer)):(a.append(b),a.pausePlay=d("."+e+"pauseplay a",a));f.pausePlay.update(c.slideshow?e+"pause":e+"play");a.pausePlay.bind(u,function(b){b.preventDefault();d(this).hasClass(e+"pause")?(a.manualPause=!0,a.manualPlay=!1,a.pause()):(a.manualPause=!1,a.manualPlay=!0,a.play())});q&&a.pausePlay.bind("click touchstart",function(a){a.preventDefault()})},update:function(b){"play"===b?a.pausePlay.removeClass(e+"pause").addClass(e+
"play").text(c.playText):a.pausePlay.removeClass(e+"play").addClass(e+"pause").text(c.pauseText)}},touch:function(){function b(b){k=m?d-b.touches[0].pageY:d-b.touches[0].pageX;q=m?Math.abs(k)<Math.abs(b.touches[0].pageX-e):Math.abs(k)<Math.abs(b.touches[0].pageY-e);if(!q||500<Number(new Date)-l)b.preventDefault(),!s&&a.transitions&&(c.animationLoop||(k/=0===a.currentSlide&&0>k||a.currentSlide===a.last&&0<k?Math.abs(k)/r+2:1),a.setProps(f+k,"setTouch"))}function g(){j.removeEventListener("touchmove",
b,!1);if(a.animatingTo===a.currentSlide&&!q&&null!==k){var h=n?-k:k,m=0<h?a.getTarget("next"):a.getTarget("prev");a.canAdvance(m)&&(550>Number(new Date)-l&&50<Math.abs(h)||Math.abs(h)>r/2)?a.flexAnimate(m,c.pauseOnAction):s||a.flexAnimate(a.currentSlide,c.pauseOnAction,!0)}j.removeEventListener("touchend",g,!1);f=k=e=d=null}var d,e,f,r,k,l,q=!1;j.addEventListener("touchstart",function(k){a.animating?k.preventDefault():1===k.touches.length&&(a.pause(),r=m?a.h:a.w,l=Number(new Date),f=h&&n&&a.animatingTo===
a.last?0:h&&n?a.limit-(a.itemW+c.itemMargin)*a.move*a.animatingTo:h&&a.currentSlide===a.last?a.limit:h?(a.itemW+c.itemMargin)*a.move*a.currentSlide:n?(a.last-a.currentSlide+a.cloneOffset)*r:(a.currentSlide+a.cloneOffset)*r,d=m?k.touches[0].pageY:k.touches[0].pageX,e=m?k.touches[0].pageX:k.touches[0].pageY,j.addEventListener("touchmove",b,!1),j.addEventListener("touchend",g,!1))},!1)},resize:function(){!a.animating&&a.is(":visible")&&(h||a.doMath(),s?f.smoothHeight():h?(a.slides.width(a.computedW),
a.update(a.pagingCount),a.setProps()):m?(a.viewport.height(a.h),a.setProps(a.h,"setTotal")):(c.smoothHeight&&f.smoothHeight(),a.newSlides.width(a.computedW),a.setProps(a.computedW,"setTotal")))},smoothHeight:function(b){if(!m||s){var c=s?a:a.viewport;b?c.animate({height:a.slides.eq(a.animatingTo).height()},b):c.height(a.slides.eq(a.animatingTo).height())}},sync:function(b){var g=d(c.sync).data("flexslider"),e=a.animatingTo;switch(b){case "animate":g.flexAnimate(e,c.pauseOnAction,!1,!0);break;case "play":!g.playing&&
!g.asNav&&g.play();break;case "pause":g.pause()}}};a.flexAnimate=function(b,g,p,j,l){t&&1===a.pagingCount&&(a.direction=a.currentItem<b?"next":"prev");if(!a.animating&&(a.canAdvance(b,l)||p)&&a.is(":visible")){if(t&&j)if(p=d(c.asNavFor).data("flexslider"),a.atEnd=0===b||b===a.count-1,p.flexAnimate(b,!0,!1,!0,l),a.direction=a.currentItem<b?"next":"prev",p.direction=a.direction,Math.ceil((b+1)/a.visible)-1!==a.currentSlide&&0!==b)a.currentItem=b,a.slides.removeClass(e+"active-slide").eq(b).addClass(e+
"active-slide"),b=Math.floor(b/a.visible);else return a.currentItem=b,a.slides.removeClass(e+"active-slide").eq(b).addClass(e+"active-slide"),!1;a.animating=!0;a.animatingTo=b;c.before(a);g&&a.pause();a.syncExists&&!l&&f.sync("animate");c.controlNav&&f.controlNav.active();h||a.slides.removeClass(e+"active-slide").eq(b).addClass(e+"active-slide");a.atEnd=0===b||b===a.last;c.directionNav&&f.directionNav.update();b===a.last&&(c.end(a),c.animationLoop||a.pause());if(s)q?(a.slides.eq(a.currentSlide).css({opacity:0,
zIndex:1}),a.slides.eq(b).css({opacity:1,zIndex:2}),a.slides.unbind("webkitTransitionEnd transitionend"),a.slides.eq(a.currentSlide).bind("webkitTransitionEnd transitionend",function(){c.after(a)}),a.animating=!1,a.currentSlide=a.animatingTo):(a.slides.eq(a.currentSlide).fadeOut(c.animationSpeed,c.easing),a.slides.eq(b).fadeIn(c.animationSpeed,c.easing,a.wrapup));else{var r=m?a.slides.filter(":first").height():a.computedW;h?(b=c.itemWidth>a.w?2*c.itemMargin:c.itemMargin,b=(a.itemW+b)*a.move*a.animatingTo,
b=b>a.limit&&1!==a.visible?a.limit:b):b=0===a.currentSlide&&b===a.count-1&&c.animationLoop&&"next"!==a.direction?n?(a.count+a.cloneOffset)*r:0:a.currentSlide===a.last&&0===b&&c.animationLoop&&"prev"!==a.direction?n?0:(a.count+1)*r:n?(a.count-1-b+a.cloneOffset)*r:(b+a.cloneOffset)*r;a.setProps(b,"",c.animationSpeed);if(a.transitions){if(!c.animationLoop||!a.atEnd)a.animating=!1,a.currentSlide=a.animatingTo;a.container.unbind("webkitTransitionEnd transitionend");a.container.bind("webkitTransitionEnd transitionend",
function(){a.wrapup(r)})}else a.container.animate(a.args,c.animationSpeed,c.easing,function(){a.wrapup(r)})}c.smoothHeight&&f.smoothHeight(c.animationSpeed)}};a.wrapup=function(b){!s&&!h&&(0===a.currentSlide&&a.animatingTo===a.last&&c.animationLoop?a.setProps(b,"jumpEnd"):a.currentSlide===a.last&&(0===a.animatingTo&&c.animationLoop)&&a.setProps(b,"jumpStart"));a.animating=!1;a.currentSlide=a.animatingTo;c.after(a)};a.animateSlides=function(){a.animating||a.flexAnimate(a.getTarget("next"))};a.pause=
function(){clearInterval(a.animatedSlides);a.playing=!1;c.pausePlay&&f.pausePlay.update("play");a.syncExists&&f.sync("pause")};a.play=function(){a.animatedSlides=setInterval(a.animateSlides,c.slideshowSpeed);a.playing=!0;c.pausePlay&&f.pausePlay.update("pause");a.syncExists&&f.sync("play")};a.canAdvance=function(b,g){var d=t?a.pagingCount-1:a.last;return g?!0:t&&a.currentItem===a.count-1&&0===b&&"prev"===a.direction?!0:t&&0===a.currentItem&&b===a.pagingCount-1&&"next"!==a.direction?!1:b===a.currentSlide&&
!t?!1:c.animationLoop?!0:a.atEnd&&0===a.currentSlide&&b===d&&"next"!==a.direction?!1:a.atEnd&&a.currentSlide===d&&0===b&&"next"===a.direction?!1:!0};a.getTarget=function(b){a.direction=b;return"next"===b?a.currentSlide===a.last?0:a.currentSlide+1:0===a.currentSlide?a.last:a.currentSlide-1};a.setProps=function(b,g,d){var e,f=b?b:(a.itemW+c.itemMargin)*a.move*a.animatingTo;e=-1*function(){if(h)return"setTouch"===g?b:n&&a.animatingTo===a.last?0:n?a.limit-(a.itemW+c.itemMargin)*a.move*a.animatingTo:a.animatingTo===
a.last?a.limit:f;switch(g){case "setTotal":return n?(a.count-1-a.currentSlide+a.cloneOffset)*b:(a.currentSlide+a.cloneOffset)*b;case "setTouch":return b;case "jumpEnd":return n?b:a.count*b;case "jumpStart":return n?a.count*b:b;default:return b}}()+"px";a.transitions&&(e=m?"translate3d(0,"+e+",0)":"translate3d("+e+",0,0)",d=void 0!==d?d/1E3+"s":"0s",a.container.css("-"+a.pfx+"-transition-duration",d));a.args[a.prop]=e;(a.transitions||void 0===d)&&a.container.css(a.args)};a.setup=function(b){if(s)a.slides.css({width:"100%",
"float":"left",marginRight:"-100%",position:"relative"}),"init"===b&&(q?a.slides.css({opacity:0,display:"block",webkitTransition:"opacity "+c.animationSpeed/1E3+"s ease",zIndex:1}).eq(a.currentSlide).css({opacity:1,zIndex:2}):a.slides.eq(a.currentSlide).fadeIn(c.animationSpeed,c.easing)),c.smoothHeight&&f.smoothHeight();else{var g,p;"init"===b&&(a.viewport=d('<div class="'+e+'viewport"></div>').css({overflow:"hidden",position:"relative"}).appendTo(a).append(a.container),a.cloneCount=0,a.cloneOffset=
0,n&&(p=d.makeArray(a.slides).reverse(),a.slides=d(p),a.container.empty().append(a.slides)));c.animationLoop&&!h&&(a.cloneCount=2,a.cloneOffset=1,"init"!==b&&a.container.find(".clone").remove(),a.container.append(a.slides.first().clone().addClass("clone")).prepend(a.slides.last().clone().addClass("clone")));a.newSlides=d(c.selector,a);g=n?a.count-1-a.currentSlide+a.cloneOffset:a.currentSlide+a.cloneOffset;m&&!h?(a.container.height(200*(a.count+a.cloneCount)+"%").css("position","absolute").width("100%"),
setTimeout(function(){a.newSlides.css({display:"block"});a.doMath();a.viewport.height(a.h);a.setProps(g*a.h,"init")},"init"===b?100:0)):(a.container.width(200*(a.count+a.cloneCount)+"%"),a.setProps(g*a.computedW,"init"),setTimeout(function(){a.doMath();a.newSlides.css({width:a.computedW,"float":"left",display:"block"});c.smoothHeight&&f.smoothHeight()},"init"===b?100:0))}h||a.slides.removeClass(e+"active-slide").eq(a.currentSlide).addClass(e+"active-slide")};a.doMath=function(){var b=a.slides.first(),
d=c.itemMargin,e=c.minItems,f=c.maxItems;a.w=a.width();a.h=b.height();a.boxPadding=b.outerWidth()-b.width();h?(a.itemT=c.itemWidth+d,a.minW=e?e*a.itemT:a.w,a.maxW=f?f*a.itemT:a.w,a.itemW=a.minW>a.w?(a.w-d*e)/e:a.maxW<a.w?(a.w-d*f)/f:c.itemWidth>a.w?a.w:c.itemWidth,a.visible=Math.floor(a.w/(a.itemW+d)),a.move=0<c.move&&c.move<a.visible?c.move:a.visible,a.pagingCount=Math.ceil((a.count-a.visible)/a.move+1),a.last=a.pagingCount-1,a.limit=1===a.pagingCount?0:c.itemWidth>a.w?(a.itemW+2*d)*a.count-a.w-
d:(a.itemW+d)*a.count-a.w-d):(a.itemW=a.w,a.pagingCount=a.count,a.last=a.count-1);a.computedW=a.itemW-a.boxPadding};a.update=function(b,d){a.doMath();h||(b<a.currentSlide?a.currentSlide+=1:b<=a.currentSlide&&0!==b&&(a.currentSlide-=1),a.animatingTo=a.currentSlide);if(c.controlNav&&!a.manualControls)if("add"===d&&!h||a.pagingCount>a.controlNav.length)f.controlNav.update("add");else if("remove"===d&&!h||a.pagingCount<a.controlNav.length)h&&a.currentSlide>a.last&&(a.currentSlide-=1,a.animatingTo-=1),
f.controlNav.update("remove",a.last);c.directionNav&&f.directionNav.update()};a.addSlide=function(b,e){var f=d(b);a.count+=1;a.last=a.count-1;m&&n?void 0!==e?a.slides.eq(a.count-e).after(f):a.container.prepend(f):void 0!==e?a.slides.eq(e).before(f):a.container.append(f);a.update(e,"add");a.slides=d(c.selector+":not(.clone)",a);a.setup();c.added(a)};a.removeSlide=function(b){var e=isNaN(b)?a.slides.index(d(b)):b;a.count-=1;a.last=a.count-1;isNaN(b)?d(b,a.slides).remove():m&&n?a.slides.eq(a.last).remove():
a.slides.eq(b).remove();a.doMath();a.update(e,"remove");a.slides=d(c.selector+":not(.clone)",a);a.setup();c.removed(a)};f.init()};d.flexslider.defaults={namespace:"flex-",selector:".slides > li",animation:"fade",easing:"swing",direction:"horizontal",reverse:!1,animationLoop:!0,smoothHeight:!1,startAt:0,slideshow:!0,slideshowSpeed:7E3,animationSpeed:600,initDelay:0,randomize:!1,pauseOnAction:!0,pauseOnHover:!1,useCSS:!0,touch:!0,video:!1,controlNav:!1,directionNav:!0,prevText:"Previous",nextText:"Next",
keyboard:!0,multipleKeyboard:!1,mousewheel:!1,pausePlay:!1,pauseText:"Pause",playText:"Play",controlsContainer:"",manualControls:"",sync:"",asNavFor:"",itemWidth:0,itemMargin:0,minItems:0,maxItems:0,move:0,start:function(){},before:function(){},after:function(){},end:function(){},added:function(){},removed:function(){}};d.fn.flexslider=function(j){void 0===j&&(j={});if("object"===typeof j)return this.each(function(){var a=d(this),c=a.find(j.selector?j.selector:".slides > li");1===c.length?(c.fadeIn(400),
j.start&&j.start(a)):void 0==a.data("flexslider")&&new d.flexslider(this,j)});var l=d(this).data("flexslider");switch(j){case "play":l.play();break;case "pause":l.pause();break;case "next":l.flexAnimate(l.getTarget("next"),!0);break;case "prev":case "previous":l.flexAnimate(l.getTarget("prev"),!0);break;default:"number"===typeof j&&l.flexAnimate(j,!0)}}})(jQuery);
// Generated by CoffeeScript 1.6.2
/*
jQuery Waypoints - v2.0.3
Copyright (c) 2011-2013 Caleb Troughton
Dual licensed under the MIT license and GPL license.
https://github.com/imakewebthings/jquery-waypoints/blob/master/licenses.txt
*/


(function() {
  var __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    __slice = [].slice;

  (function(root, factory) {
    if (typeof define === 'function' && define.amd) {
      return define('waypoints', ['jquery'], function($) {
        return factory($, root);
      });
    } else {
      return factory(root.jQuery, root);
    }
  })(this, function($, window) {
    var $w, Context, Waypoint, allWaypoints, contextCounter, contextKey, contexts, isTouch, jQMethods, methods, resizeEvent, scrollEvent, waypointCounter, waypointKey, wp, wps;

    $w = $(window);
    isTouch = __indexOf.call(window, 'ontouchstart') >= 0;
    allWaypoints = {
      horizontal: {},
      vertical: {}
    };
    contextCounter = 1;
    contexts = {};
    contextKey = 'waypoints-context-id';
    resizeEvent = 'resize.waypoints';
    scrollEvent = 'scroll.waypoints';
    waypointCounter = 1;
    waypointKey = 'waypoints-waypoint-ids';
    wp = 'waypoint';
    wps = 'waypoints';
    Context = (function() {
      function Context($element) {
        var _this = this;

        this.$element = $element;
        this.element = $element[0];
        this.didResize = false;
        this.didScroll = false;
        this.id = 'context' + contextCounter++;
        this.oldScroll = {
          x: $element.scrollLeft(),
          y: $element.scrollTop()
        };
        this.waypoints = {
          horizontal: {},
          vertical: {}
        };
        $element.data(contextKey, this.id);
        contexts[this.id] = this;
        $element.bind(scrollEvent, function() {
          var scrollHandler;

          if (!(_this.didScroll || isTouch)) {
            _this.didScroll = true;
            scrollHandler = function() {
              _this.doScroll();
              return _this.didScroll = false;
            };
            return window.setTimeout(scrollHandler, $[wps].settings.scrollThrottle);
          }
        });
        $element.bind(resizeEvent, function() {
          var resizeHandler;

          if (!_this.didResize) {
            _this.didResize = true;
            resizeHandler = function() {
              $[wps]('refresh');
              return _this.didResize = false;
            };
            return window.setTimeout(resizeHandler, $[wps].settings.resizeThrottle);
          }
        });
      }

      Context.prototype.doScroll = function() {
        var axes,
          _this = this;

        axes = {
          horizontal: {
            newScroll: this.$element.scrollLeft(),
            oldScroll: this.oldScroll.x,
            forward: 'right',
            backward: 'left'
          },
          vertical: {
            newScroll: this.$element.scrollTop(),
            oldScroll: this.oldScroll.y,
            forward: 'down',
            backward: 'up'
          }
        };
        if (isTouch && (!axes.vertical.oldScroll || !axes.vertical.newScroll)) {
          $[wps]('refresh');
        }
        $.each(axes, function(aKey, axis) {
          var direction, isForward, triggered;

          triggered = [];
          isForward = axis.newScroll > axis.oldScroll;
          direction = isForward ? axis.forward : axis.backward;
          $.each(_this.waypoints[aKey], function(wKey, waypoint) {
            var _ref, _ref1;

            if ((axis.oldScroll < (_ref = waypoint.offset) && _ref <= axis.newScroll)) {
              return triggered.push(waypoint);
            } else if ((axis.newScroll < (_ref1 = waypoint.offset) && _ref1 <= axis.oldScroll)) {
              return triggered.push(waypoint);
            }
          });
          triggered.sort(function(a, b) {
            return a.offset - b.offset;
          });
          if (!isForward) {
            triggered.reverse();
          }
          return $.each(triggered, function(i, waypoint) {
            if (waypoint.options.continuous || i === triggered.length - 1) {
              return waypoint.trigger([direction]);
            }
          });
        });
        return this.oldScroll = {
          x: axes.horizontal.newScroll,
          y: axes.vertical.newScroll
        };
      };

      Context.prototype.refresh = function() {
        var axes, cOffset, isWin,
          _this = this;

        isWin = $.isWindow(this.element);
        cOffset = this.$element.offset();
        this.doScroll();
        axes = {
          horizontal: {
            contextOffset: isWin ? 0 : cOffset.left,
            contextScroll: isWin ? 0 : this.oldScroll.x,
            contextDimension: this.$element.width(),
            oldScroll: this.oldScroll.x,
            forward: 'right',
            backward: 'left',
            offsetProp: 'left'
          },
          vertical: {
            contextOffset: isWin ? 0 : cOffset.top,
            contextScroll: isWin ? 0 : this.oldScroll.y,
            contextDimension: isWin ? $[wps]('viewportHeight') : this.$element.height(),
            oldScroll: this.oldScroll.y,
            forward: 'down',
            backward: 'up',
            offsetProp: 'top'
          }
        };
        return $.each(axes, function(aKey, axis) {
          return $.each(_this.waypoints[aKey], function(i, waypoint) {
            var adjustment, elementOffset, oldOffset, _ref, _ref1;

            adjustment = waypoint.options.offset;
            oldOffset = waypoint.offset;
            elementOffset = $.isWindow(waypoint.element) ? 0 : waypoint.$element.offset()[axis.offsetProp];
            if ($.isFunction(adjustment)) {
              adjustment = adjustment.apply(waypoint.element);
            } else if (typeof adjustment === 'string') {
              adjustment = parseFloat(adjustment);
              if (waypoint.options.offset.indexOf('%') > -1) {
                adjustment = Math.ceil(axis.contextDimension * adjustment / 100);
              }
            }
            waypoint.offset = elementOffset - axis.contextOffset + axis.contextScroll - adjustment;
            if ((waypoint.options.onlyOnScroll && (oldOffset != null)) || !waypoint.enabled) {
              return;
            }
            if (oldOffset !== null && (oldOffset < (_ref = axis.oldScroll) && _ref <= waypoint.offset)) {
              return waypoint.trigger([axis.backward]);
            } else if (oldOffset !== null && (oldOffset > (_ref1 = axis.oldScroll) && _ref1 >= waypoint.offset)) {
              return waypoint.trigger([axis.forward]);
            } else if (oldOffset === null && axis.oldScroll >= waypoint.offset) {
              return waypoint.trigger([axis.forward]);
            }
          });
        });
      };

      Context.prototype.checkEmpty = function() {
        if ($.isEmptyObject(this.waypoints.horizontal) && $.isEmptyObject(this.waypoints.vertical)) {
          this.$element.unbind([resizeEvent, scrollEvent].join(' '));
          return delete contexts[this.id];
        }
      };

      return Context;

    })();
    Waypoint = (function() {
      function Waypoint($element, context, options) {
        var idList, _ref;

        options = $.extend({}, $.fn[wp].defaults, options);
        if (options.offset === 'bottom-in-view') {
          options.offset = function() {
            var contextHeight;

            contextHeight = $[wps]('viewportHeight');
            if (!$.isWindow(context.element)) {
              contextHeight = context.$element.height();
            }
            return contextHeight - $(this).outerHeight();
          };
        }
        this.$element = $element;
        this.element = $element[0];
        this.axis = options.horizontal ? 'horizontal' : 'vertical';
        this.callback = options.handler;
        this.context = context;
        this.enabled = options.enabled;
        this.id = 'waypoints' + waypointCounter++;
        this.offset = null;
        this.options = options;
        context.waypoints[this.axis][this.id] = this;
        allWaypoints[this.axis][this.id] = this;
        idList = (_ref = $element.data(waypointKey)) != null ? _ref : [];
        idList.push(this.id);
        $element.data(waypointKey, idList);
      }

      Waypoint.prototype.trigger = function(args) {
        if (!this.enabled) {
          return;
        }
        if (this.callback != null) {
          this.callback.apply(this.element, args);
        }
        if (this.options.triggerOnce) {
          return this.destroy();
        }
      };

      Waypoint.prototype.disable = function() {
        return this.enabled = false;
      };

      Waypoint.prototype.enable = function() {
        this.context.refresh();
        return this.enabled = true;
      };

      Waypoint.prototype.destroy = function() {
        delete allWaypoints[this.axis][this.id];
        delete this.context.waypoints[this.axis][this.id];
        return this.context.checkEmpty();
      };

      Waypoint.getWaypointsByElement = function(element) {
        var all, ids;

        ids = $(element).data(waypointKey);
        if (!ids) {
          return [];
        }
        all = $.extend({}, allWaypoints.horizontal, allWaypoints.vertical);
        return $.map(ids, function(id) {
          return all[id];
        });
      };

      return Waypoint;

    })();
    methods = {
      init: function(f, options) {
        var _ref;

        if (options == null) {
          options = {};
        }
        if ((_ref = options.handler) == null) {
          options.handler = f;
        }
        this.each(function() {
          var $this, context, contextElement, _ref1;

          $this = $(this);
          contextElement = (_ref1 = options.context) != null ? _ref1 : $.fn[wp].defaults.context;
          if (!$.isWindow(contextElement)) {
            contextElement = $this.closest(contextElement);
          }
          contextElement = $(contextElement);
          context = contexts[contextElement.data(contextKey)];
          if (!context) {
            context = new Context(contextElement);
          }
          return new Waypoint($this, context, options);
        });
        $[wps]('refresh');
        return this;
      },
      disable: function() {
        return methods._invoke(this, 'disable');
      },
      enable: function() {
        return methods._invoke(this, 'enable');
      },
      destroy: function() {
        return methods._invoke(this, 'destroy');
      },
      prev: function(axis, selector) {
        return methods._traverse.call(this, axis, selector, function(stack, index, waypoints) {
          if (index > 0) {
            return stack.push(waypoints[index - 1]);
          }
        });
      },
      next: function(axis, selector) {
        return methods._traverse.call(this, axis, selector, function(stack, index, waypoints) {
          if (index < waypoints.length - 1) {
            return stack.push(waypoints[index + 1]);
          }
        });
      },
      _traverse: function(axis, selector, push) {
        var stack, waypoints;

        if (axis == null) {
          axis = 'vertical';
        }
        if (selector == null) {
          selector = window;
        }
        waypoints = jQMethods.aggregate(selector);
        stack = [];
        this.each(function() {
          var index;

          index = $.inArray(this, waypoints[axis]);
          return push(stack, index, waypoints[axis]);
        });
        return this.pushStack(stack);
      },
      _invoke: function($elements, method) {
        $elements.each(function() {
          var waypoints;

          waypoints = Waypoint.getWaypointsByElement(this);
          return $.each(waypoints, function(i, waypoint) {
            waypoint[method]();
            return true;
          });
        });
        return this;
      }
    };
    $.fn[wp] = function() {
      var args, method;

      method = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      if (methods[method]) {
        return methods[method].apply(this, args);
      } else if ($.isFunction(method)) {
        return methods.init.apply(this, arguments);
      } else if ($.isPlainObject(method)) {
        return methods.init.apply(this, [null, method]);
      } else if (!method) {
        return $.error("jQuery Waypoints needs a callback function or handler option.");
      } else {
        return $.error("The " + method + " method does not exist in jQuery Waypoints.");
      }
    };
    $.fn[wp].defaults = {
      context: window,
      continuous: true,
      enabled: true,
      horizontal: false,
      offset: 0,
      triggerOnce: false
    };
    jQMethods = {
      refresh: function() {
        return $.each(contexts, function(i, context) {
          return context.refresh();
        });
      },
      viewportHeight: function() {
        var _ref;

        return (_ref = window.innerHeight) != null ? _ref : $w.height();
      },
      aggregate: function(contextSelector) {
        var collection, waypoints, _ref;

        collection = allWaypoints;
        if (contextSelector) {
          collection = (_ref = contexts[$(contextSelector).data(contextKey)]) != null ? _ref.waypoints : void 0;
        }
        if (!collection) {
          return [];
        }
        waypoints = {
          horizontal: [],
          vertical: []
        };
        $.each(waypoints, function(axis, arr) {
          $.each(collection[axis], function(key, waypoint) {
            return arr.push(waypoint);
          });
          arr.sort(function(a, b) {
            return a.offset - b.offset;
          });
          waypoints[axis] = $.map(arr, function(waypoint) {
            return waypoint.element;
          });
          return waypoints[axis] = $.unique(waypoints[axis]);
        });
        return waypoints;
      },
      above: function(contextSelector) {
        if (contextSelector == null) {
          contextSelector = window;
        }
        return jQMethods._filter(contextSelector, 'vertical', function(context, waypoint) {
          return waypoint.offset <= context.oldScroll.y;
        });
      },
      below: function(contextSelector) {
        if (contextSelector == null) {
          contextSelector = window;
        }
        return jQMethods._filter(contextSelector, 'vertical', function(context, waypoint) {
          return waypoint.offset > context.oldScroll.y;
        });
      },
      left: function(contextSelector) {
        if (contextSelector == null) {
          contextSelector = window;
        }
        return jQMethods._filter(contextSelector, 'horizontal', function(context, waypoint) {
          return waypoint.offset <= context.oldScroll.x;
        });
      },
      right: function(contextSelector) {
        if (contextSelector == null) {
          contextSelector = window;
        }
        return jQMethods._filter(contextSelector, 'horizontal', function(context, waypoint) {
          return waypoint.offset > context.oldScroll.x;
        });
      },
      enable: function() {
        return jQMethods._invoke('enable');
      },
      disable: function() {
        return jQMethods._invoke('disable');
      },
      destroy: function() {
        return jQMethods._invoke('destroy');
      },
      extendFn: function(methodName, f) {
        return methods[methodName] = f;
      },
      _invoke: function(method) {
        var waypoints;

        waypoints = $.extend({}, allWaypoints.vertical, allWaypoints.horizontal);
        return $.each(waypoints, function(key, waypoint) {
          waypoint[method]();
          return true;
        });
      },
      _filter: function(selector, axis, test) {
        var context, waypoints;

        context = contexts[$(selector).data(contextKey)];
        if (!context) {
          return [];
        }
        waypoints = [];
        $.each(context.waypoints[axis], function(i, waypoint) {
          if (test(context, waypoint)) {
            return waypoints.push(waypoint);
          }
        });
        waypoints.sort(function(a, b) {
          return a.offset - b.offset;
        });
        return $.map(waypoints, function(waypoint) {
          return waypoint.element;
        });
      }
    };
    $[wps] = function() {
      var args, method;

      method = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      if (jQMethods[method]) {
        return jQMethods[method].apply(null, args);
      } else {
        return jQMethods.aggregate.call(null, method);
      }
    };
    $[wps].settings = {
      resizeThrottle: 100,
      scrollThrottle: 30
    };
    return $w.load(function() {
      return $[wps]('refresh');
    });
  });

}).call(this);

;(function (window, document, $, undefined) {

	$.swipebox = function(elem, options) {

		var defaults = {
			useCSS : true,
			initialIndexOnArray : 0,
			hideBarsDelay : 3000,
			videoMaxWidth : 1140,
			vimeoColor : 'CCCCCC',
			beforeOpen: null,
		      	afterClose: null
		},

		plugin = this,
		elements = [], // slides array [{href:'...', title:'...'}, ...],
		elem = elem,
		selector = elem.selector,
		$selector = $(selector),
		isTouch = document.createTouch !== undefined || ('ontouchstart' in window) || ('onmsgesturechange' in window) || navigator.msMaxTouchPoints,
		supportSVG = !!(window.SVGSVGElement),
		winWidth = window.innerWidth ? window.innerWidth : $(window).width(),
		winHeight = window.innerHeight ? window.innerHeight : $(window).height(),
		html = '<div id="swipebox-overlay">\
				<div id="swipebox-slider"></div>\
				<div id="swipebox-caption"></div>\
				<div id="swipebox-action">\
					<a id="swipebox-close"></a>\
					<a id="swipebox-prev"></a>\
					<a id="swipebox-next"></a>\
				</div>\
		</div>';

		plugin.settings = {}

		plugin.init = function(){

			plugin.settings = $.extend({}, defaults, options);

			if ($.isArray(elem)) {

				elements = elem;
				ui.target = $(window);
				ui.init(plugin.settings.initialIndexOnArray);

			}else{

				$selector.click(function(e){
					elements = [];
					var index , relType, relVal;

					if (!relVal) {
						relType = 'rel';
						relVal  = $(this).attr(relType);
					}

					if (relVal && relVal !== '' && relVal !== 'nofollow') {
						$elem = $selector.filter('[' + relType + '="' + relVal + '"]');
					}else{
						$elem = $(selector);
					}

					$elem.each(function(){

						var title = null, href = null;

						if( $(this).attr('title') )
							title = $(this).attr('title');

						if( $(this).attr('href') )
							href = $(this).attr('href');

						elements.push({
							href: href,
							title: title
						});
					});

					index = $elem.index($(this));
					e.preventDefault();
					e.stopPropagation();
					ui.target = $(e.target);
					ui.init(index);
				});
			}
		}

		plugin.refresh = function() {
			if (!$.isArray(elem)) {
				ui.destroy();
				$elem = $(selector);
				ui.actions();
			}
		}

		var ui = {

			init : function(index){
				if (plugin.settings.beforeOpen)
					plugin.settings.beforeOpen();
				this.target.trigger('swipebox-start');
				$.swipebox.isOpen = true;
				this.build();
				this.openSlide(index);
				this.openMedia(index);
				this.preloadMedia(index+1);
				this.preloadMedia(index-1);
			},

			build : function(){
				var $this = this;

				$('body').append(html);

				if($this.doCssTrans()){
					$('#swipebox-slider').css({
						'-webkit-transition' : 'left 0.4s ease',
						'-moz-transition' : 'left 0.4s ease',
						'-o-transition' : 'left 0.4s ease',
						'-khtml-transition' : 'left 0.4s ease',
						'transition' : 'left 0.4s ease'
					});
					$('#swipebox-overlay').css({
						'-webkit-transition' : 'opacity 1s ease',
						'-moz-transition' : 'opacity 1s ease',
						'-o-transition' : 'opacity 1s ease',
						'-khtml-transition' : 'opacity 1s ease',
						'transition' : 'opacity 1s ease'
					});
					$('#swipebox-action, #swipebox-caption').css({
						'-webkit-transition' : '0.5s',
						'-moz-transition' : '0.5s',
						'-o-transition' : '0.5s',
						'-khtml-transition' : '0.5s',
						'transition' : '0.5s'
					});
				}


				if(supportSVG){
					var bg = $('#swipebox-action #swipebox-close').css('background-image');
					bg = bg.replace('png', 'svg');
					$('#swipebox-action #swipebox-prev,#swipebox-action #swipebox-next,#swipebox-action #swipebox-close').css({
						'background-image' : bg
					});
				}

				$.each( elements,  function(){
					$('#swipebox-slider').append('<div class="slide"></div>');
				});

				$this.setDim();
				$this.actions();
				$this.keyboard();
				$this.gesture();
				$this.animBars();
				$this.resize();

			},

			setDim : function(){

				var width, height, sliderCss = {};

				if( "onorientationchange" in window ){

					window.addEventListener("orientationchange", function() {
						if( window.orientation == 0 ){
							width = winWidth;
							height = winHeight;
						}else if( window.orientation == 90 || window.orientation == -90 ){
							width = winHeight;
							height = winWidth;
						}
					}, false);


				}else{

					width = window.innerWidth ? window.innerWidth : $(window).width();
					height = window.innerHeight ? window.innerHeight : $(window).height();
				}

				sliderCss = {
					width : width,
					height : height
				}


				$('#swipebox-overlay').css(sliderCss);

			},

			resize : function (){
				var $this = this;

				$(window).resize(function() {
					$this.setDim();
				}).resize();
			},

			supportTransition : function() {
				var prefixes = 'transition WebkitTransition MozTransition OTransition msTransition KhtmlTransition'.split(' ');
				for(var i = 0; i < prefixes.length; i++) {
					if(document.createElement('div').style[prefixes[i]] !== undefined) {
						return prefixes[i];
					}
				}
				return false;
			},

			doCssTrans : function(){
				if(plugin.settings.useCSS && this.supportTransition() ){
					return true;
				}
			},

			gesture : function(){
				if ( isTouch ){
					var $this = this,
					distance = null,
					swipMinDistance = 10,
					startCoords = {},
					endCoords = {};
					var bars = $('#swipebox-caption, #swipebox-action');

					bars.addClass('visible-bars');
					$this.setTimeout();

					$('body').bind('touchstart', function(e){

						$(this).addClass('touching');

		  				endCoords = e.originalEvent.targetTouches[0];
		    				startCoords.pageX = e.originalEvent.targetTouches[0].pageX;

						$('.touching').bind('touchmove',function(e){
							e.preventDefault();
							e.stopPropagation();
		    					endCoords = e.originalEvent.targetTouches[0];

						});

			           			return false;

	           			}).bind('touchend',function(e){
	           				e.preventDefault();
					e.stopPropagation();

   					distance = endCoords.pageX - startCoords.pageX;

	       				if( distance >= swipMinDistance ){

	       					// swipeLeft
	       					$this.getPrev();

	       				}else if( distance <= - swipMinDistance ){

	       					// swipeRight
	       					$this.getNext();

	       				}else{
	       					// tap
	       					if(!bars.hasClass('visible-bars')){
							$this.showBars();
							$this.setTimeout();
						}else{
							$this.clearTimeout();
							$this.hideBars();
						}

	       				}

	       				$('.touching').off('touchmove').removeClass('touching');

					});

           				}
			},

			setTimeout: function(){
				if(plugin.settings.hideBarsDelay > 0){
					var $this = this;
					$this.clearTimeout();
					$this.timeout = window.setTimeout( function(){
						$this.hideBars() },
						plugin.settings.hideBarsDelay
					);
				}
			},

			clearTimeout: function(){
				window.clearTimeout(this.timeout);
				this.timeout = null;
			},

			showBars : function(){
				var bars = $('#swipebox-caption, #swipebox-action');
				if(this.doCssTrans()){
					bars.addClass('visible-bars');
				}else{
					$('#swipebox-caption').animate({ top : 0 }, 500);
					$('#swipebox-action').animate({ bottom : 0 }, 500);
					setTimeout(function(){
						bars.addClass('visible-bars');
					}, 1000);
				}
			},

			hideBars : function(){
				var bars = $('#swipebox-caption, #swipebox-action');
				if(this.doCssTrans()){
					bars.removeClass('visible-bars');
				}else{
					$('#swipebox-caption').animate({ top : '-50px' }, 500);
					$('#swipebox-action').animate({ bottom : '-50px' }, 500);
					setTimeout(function(){
						bars.removeClass('visible-bars');
					}, 1000);
				}
			},

			animBars : function(){
				var $this = this;
				var bars = $('#swipebox-caption, #swipebox-action');

				bars.addClass('visible-bars');
				$this.setTimeout();

				$('#swipebox-slider').click(function(e){
					if(!bars.hasClass('visible-bars')){
						$this.showBars();
						$this.setTimeout();
					}
				});

				$('#swipebox-action').hover(function() {
				  		$this.showBars();
						bars.addClass('force-visible-bars');
						$this.clearTimeout();

					},function() {
						bars.removeClass('force-visible-bars');
						$this.setTimeout();

				});
			},

			keyboard : function(){
				var $this = this;
				$(window).bind('keyup', function(e){
					e.preventDefault();
					e.stopPropagation();
					if (e.keyCode == 37){
						$this.getPrev();
					}
					else if (e.keyCode==39){
						$this.getNext();
					}
					else if (e.keyCode == 27) {
						$this.closeSlide();
					}
				});
			},

			actions : function(){
				var $this = this;

				if( elements.length < 2 ){
					$('#swipebox-prev, #swipebox-next').hide();
				}else{
					$('#swipebox-prev').bind('click touchend', function(e){
						e.preventDefault();
						e.stopPropagation();
						$this.getPrev();
						$this.setTimeout();
					});

					$('#swipebox-next').bind('click touchend', function(e){
						e.preventDefault();
						e.stopPropagation();
						$this.getNext();
						$this.setTimeout();
					});
				}

				$('#swipebox-close').bind('click touchend', function(e){
					$this.closeSlide();
				});
			},

			setSlide : function (index, isFirst){
				isFirst = isFirst || false;

				var slider = $('#swipebox-slider');

				if(this.doCssTrans()){
					slider.css({ left : (-index*100)+'%' });
				}else{
					slider.animate({ left : (-index*100)+'%' });
				}

				$('#swipebox-slider .slide').removeClass('current');
				$('#swipebox-slider .slide').eq(index).addClass('current');
				this.setTitle(index);

				if( isFirst ){
					slider.fadeIn();
				}

				$('#swipebox-prev, #swipebox-next').removeClass('disabled');
				if(index == 0){
					$('#swipebox-prev').addClass('disabled');
				}else if( index == elements.length - 1 ){
					$('#swipebox-next').addClass('disabled');
				}
			},

			openSlide : function (index){
				$('html').addClass('swipebox');
				$(window).trigger('resize'); // fix scroll bar visibility on desktop
				this.setSlide(index, true);
			},

			preloadMedia : function (index){
				var $this = this, src = null;

				if( elements[index] !== undefined )
					src = elements[index].href;

				if( !$this.isVideo(src) ){
					setTimeout(function(){
						$this.openMedia(index);
					}, 1000);
				}else{
					$this.openMedia(index);
				}
			},

			openMedia : function (index){
				var $this = this, src = null;

				if( elements[index] !== undefined )
					src = elements[index].href;

				if(index < 0 || index >= elements.length){
					return false;
				}

				if( !$this.isVideo(src) ){
					$this.loadMedia(src, function(){
						$('#swipebox-slider .slide').eq(index).html(this);
					});
				}else{
					$('#swipebox-slider .slide').eq(index).html($this.getVideo(src));
					window.playOoyala(); // Hook to play the Ooyala player
				}

			},

			setTitle : function (index, isFirst){
				var title = null;

				$('#swipebox-caption').empty();

				if( elements[index] !== undefined )
					title = elements[index].title;

				if(title){
					$('#swipebox-caption').append(title);
				}
			},

			isVideo : function (src){

				if( src ){
					if(
						src.match(/youtube\.com\/watch\?v=([a-zA-Z0-9\-_]+)/)
						|| src.match(/vimeo\.com\/([0-9]*)/)
						|| src.match(/ooyala\.com\/([0-9]*)/)
					){
						return true;
					}
				}

			},

			getVideo : function(url){
				var iframe = '';
				var output = '';
				var youtubeUrl = url.match(/watch\?v=([a-zA-Z0-9\-_]+)/);
		        var vimeoUrl = url.match(/vimeo\.com\/([0-9]*)/);
				var ooUrl = url.match(/ooyala\.com\/([0-9]*)/);

				if( youtubeUrl ){
					iframe = '<iframe width="560" height="315" src="//www.youtube.com/embed/'+youtubeUrl[1]+'" frameborder="0" allowfullscreen></iframe>';
				}
				else if(vimeoUrl)
				{
					iframe = '<iframe width="560" height="315"  src="http://player.vimeo.com/video/'+vimeoUrl[1]+'?byline=0&amp;portrait=0&amp;color='+plugin.settings.vimeoColor+'" frameborder="0" webkitAllowFullScreen mozallowfullscreen allowFullScreen></iframe>';
				}
				else if(ooUrl)
				{
					iframe  = '<div id="ooyalaplayer" class="ooyala-player" width="560" height="315"></div>';
					// iframe += '<script>OO.ready(function() { var ooPlayer = OO.Player.create("ooyalaplayer", "tkaGMwZTrI0iyfSTcvJHpYHI8EAW0LQO"); ooPlayer.play();});</script>';
				}
				return '<div class="swipebox-video-container" style="max-width:'+plugin.settings.videomaxWidth+'px"><div class="swipebox-video">'+iframe+'</div></div>';
			},

			loadMedia : function (src, callback){
				if( !this.isVideo(src) ){
					var img = $('<img>').on('load', function(){
						callback.call(img);
					});

					img.attr('src',src);
				}
			},

			getNext : function (){
				var $this = this;
				index = $('#swipebox-slider .slide').index($('#swipebox-slider .slide.current'));
				if(index+1 < elements.length){
					index++;
					$this.setSlide(index);
					$this.preloadMedia(index+1);
				}
				else{

					$('#swipebox-slider').addClass('rightSpring');
					setTimeout(function(){
						$('#swipebox-slider').removeClass('rightSpring');
					},500);
				}
			},

			getPrev : function (){
				index = $('#swipebox-slider .slide').index($('#swipebox-slider .slide.current'));
				if(index > 0){
					index--;
					this.setSlide(index);
					this.preloadMedia(index-1);
				}
				else{

					$('#swipebox-slider').addClass('leftSpring');
					setTimeout(function(){
						$('#swipebox-slider').removeClass('leftSpring');
					},500);
				}
			},


			closeSlide : function (){
				$('html').removeClass('swipebox');
				$(window).trigger('resize');
				window.destroyOoyala();
				this.destroy();
			},

			destroy : function(){
				$(window).unbind('keyup');
				$('body').unbind('touchstart');
				$('body').unbind('touchmove');
				$('body').unbind('touchend');
				$('#swipebox-slider').unbind();
				$('#swipebox-overlay').remove();
				if (!$.isArray(elem))
					elem.removeData('_swipebox');
				if ( this.target )
					this.target.trigger('swipebox-destroy');
				$.swipebox.isOpen = false;
				if (plugin.settings.afterClose)
					plugin.settings.afterClose();
 			}

		};

		plugin.init();

	};

	$.fn.swipebox = function(options){
		if (!$.data(this, "_swipebox")) {
			var swipebox = new $.swipebox(this, options);
			this.data('_swipebox', swipebox);
		}
		return this.data('_swipebox');
	}

}(window, document, jQuery));

/*!
 * Rolling Stone HTML5 Project
 * @author Todd Motto
 * @version 1.0.0
 * Copyright 2013.
 */
(function ($, window, document) {

  $(function () {

    'use strict';

    /**
     * Ooyala
     */
    var script = document.createElement('script');
    script.src = '//player.ooyala.com/v3/M2IxMTZiNDExZmU1MDIyOTc2NzA0NmVi';
    var head = document.head || document.getElementsByTagName('head')[0];
    head.appendChild(script);

    window.playOoyala = function() {
      OO.ready(
        function() {
          if( typeof ooPlayer !== undefined)
          {
            window.ooPlayer = OO.Player.create("ooyalaplayer", "tkaGMwZTrI0iyfSTcvJHpYHI8EAW0LQO");
          }
          ooPlayer.play();
        }
      );
    }

    window.destroyOoyala = function() {
      if(typeof window.ooPlayer != 'undefined')
      {
        window.ooPlayer.destroy();
      }
    }

    $('.swipebox').swipebox();
    $('.swipebox-waterfall').swipebox();

    /**
     * Window load
     */
    $(window).load(function() {
      $('.loader__detail').delay(1000).animate({
        'top' : '-500px'
      }, 350, function () {
        $('.loader').fadeOut().remove();
        $('.content').fadeIn();
      });
    });

    /*var getImgHeights = function () {
      var image1 = $('img[src="img/intro/intro.jpg"]').height();
      var image2 = $('img[src="img/intro/intro-1.jpg"]').height();
      var image3 = $('img[src="img/intro/intro-2.jpg"]').height();
      var image4 = $('img[src="img/intro/intro-3.jpg"]').height();
      var all = image1 + image2 + image3 + image4 - 200;
      $('.inside__waterfall').height(all);
    };
    getImgHeights();
    window.onresize = function () {
      getImgHeights();
    };*/

    /**
     * Flexslider
     */
    $('.miami-slider').waypoint(function () {
      if ($('.flexslider').length) {
        $('.flexslider').flexslider({
          animation:'slide',
          namespace:'slide-'
        });
      }
    },{ offset: '100%' });

    /**
     * Accordion widget
     */
    $('.mobman__expand--icon').on('click', function () {
      var self = $(this);
      var parent = self.parents('[data-content]')
      parent.removeClass('expand-active');
      parent.prev().removeClass('expand-active');
    });
    $('[data-expand]').on('click', function (e) {
        var self = $(this);
        // var expanded = self.data('expanded');
        // self.data('expanded', !expanded);
        if (!self.hasClass('expand-active')) {
            self.addClass('expand-active').siblings('[data-expand]').removeClass('expand-active');
            self.siblings('[data-content=' + self.data('expand') + ']').addClass('expand-active').siblings('[data-content]').removeClass('expand-active');
            $('html, body').animate({
              scrollTop: $(this).offset().top - 50
            });
        } else {
            self.removeClass('expand-active');
            self.siblings('[data-content=' + self.data('expand') + ']').removeClass('expand-active');
        }
        e.preventDefault();
    });

    /**
     * Support message
     */
    $('.support__continue').on('click', function (e) {
      $(this).parents('.support').fadeOut(300);
      e.preventDefault();
    });

    /**
     * Waterfall
     */
    // if ($(window).width() > 768) {
      var waterimgs = $('.intro-img-1,.intro-img-2,.intro-img-3,.intro-img-4');
      if(!isTouchDevice()){
      waterimgs.css({opacity:0});
        waterimgs.waypoint(function (direction) {
          if (direction === 'down') $(this).transition({opacity:1, duration:200});
          else $(this).transition({opacity:0, duration:200});
        }, { offset: 'bottom-in-view' });
      }
    // }

    /**
     * Waterfall dynamic height for images
     */
    // var waterfall = function () {
    //   $('.inside__waterfall').css({
    //     height : $('.inside__text').outerHeight()
    //   });
    // };
    // waterfall();
    // window.onresize = function () {
    //   waterfall();
    // };

    initializeHeaderSocialButtons();
    if(isTouchDevice()){
      var $a = $('.bonvillian__img');
      $a.css({display:'none'});
      var $b = $('.bonvillian__img--mobile');
      $b.css({display:'block'});

      //Disable Todd video on iPad widescreen
      var $toddVideoImage = $('img.todd__video');
      $toddVideoImage.removeClass('widescreen smallscreen').css('display:block !important');
      var toddVideo = $('video.todd__video')[0];
      toddVideo.parentElement.removeChild(toddVideo);

      initializeParallaxForImage($('div.wrecking__img__img')[0], 0);
      initializeParallaxForImage($('div.mobman__full__img')[0], 0);
      initializeParallaxForImage($('div.nccic__img')[0], 0);

    }else{
      initializeBonvillianHitchcockZoomEffect();
      initializeParallaxForImage($('div.wrecking__img__img')[0], 200);
      initializeParallaxForImage($('div.mobman__full__img')[0], 200);
      initializeParallaxForImage($('div.nccic__img')[0], 200);
    }

    setTimeout(function(){
        initializeGlitchyImages();
    }, 1000);

  });

})(jQuery, window, document);

function initializeBonvillianHitchcockZoomEffect(){
  var bonvillian = $('.bonvillian__img')[0];
  var bonvillian__cutout = $(bonvillian).find('.bonvillian__img__cutout')[0];
  var bonvillian__background = $(bonvillian).find('.bonvillian__img__background')[0];

  $(window).bind('scroll resize', function(event){
    onScrollOrResize();
  });

  onScrollOrResize();//Run once to initialize.

  function onScrollOrResize(){
    if(isElementVisible(bonvillian)){
      //Start the hitchcock effect when the middle of the bonvillian image reaches the bottom of the viewport (0%).
      //End the hitchcock effect when the middle of the bonvillian image reaches the top of the viewport (100%).
      var b = bonvillianVerticalCenterViewportY = bonvillian.getBoundingClientRect().top + bonvillian.offsetHeight/2;
      var p = percentScrolledThroughScreen = (window.innerHeight - b) / window.innerHeight;
      if(p < 0) p = 0;
      if(p > 1) p = 1;
      //console.log(p); if(Math.random() > .7) console.clear();

      var w = bonvillian.offsetWidth;
      var pw = 1280;/* prototype width */
      var ar = w/pw;/* aspect ratio */

      var perspective = eval(100 * ar)+'px';
      var perspectiveCSS = {
        '-webkit-perspective': perspective,
        '-moz-perspective': perspective,
        'perspective': perspective
      }
      $(bonvillian).css(perspectiveCSS);//This does not work in IE! It adds "transform: perspective()" instead of the perspective property.
      //$(bonvillian).transition({perspective:perspective, duration:0});//Uses transit to apply browser-specific styles.

      var cutoutZStart = 35 * ar;//Controls size/depth
      var cutoutZEnd = 50 * ar;
      var cutoutZ = cutoutZStart + p * (cutoutZEnd - cutoutZStart);

      var cutoutYStart = -120 * ar;
      var cutoutYEnd = -160 * ar;
      var cutoutY = cutoutYStart + p * (cutoutYEnd - cutoutYStart);

      var cutoutTransform = 'translateZ('+cutoutZ+'px) translateY('+cutoutY+'px)';
      var cutoutCSS = {
        '-webkit-transform': cutoutTransform,
        '-moz-transform': cutoutTransform,
        'transform': cutoutTransform
      }
      $(bonvillian__cutout).css(cutoutCSS);
      /*$(bonvillian__cutout).css({//Uses transit to apply browser-specific styles.
        translateZ:cutoutZ+'px',
        translateY:cutoutZ+'px'
      });*/

      var backgroundZStart = 20 * ar;//Control size/depth
      var backgroundZEnd = 0 * ar;
      var backgroundZ = backgroundZStart + p * (backgroundZEnd - backgroundZStart);

      var backgroundBlurStart = 0 * ar;
      var backgroundBlurEnd = 7 * ar;
      var backgroundBlur = backgroundBlurStart + p * (backgroundBlurEnd - backgroundBlurStart);
      var blurFilter = 'blur('+backgroundBlur+'px)';

      var backgroundTransform = 'translateZ('+backgroundZ+'px)';
      var backgroundCSS = {
        '-webkit-transform': backgroundTransform,
        '-moz-transform': backgroundTransform,
        'transform': backgroundTransform,

        '-webkit-filter': blurFilter,
        '-moz-filter': blurFilter,
        '-ms-filter': blurFilter,
        'filter': blurFilter
      }
      $(bonvillian__background).css(backgroundCSS);
      /*$(bonvillian__background).css({//Uses transit to apply browser-specific styles.
        translateZ:backgroundZ+'px',
        filter:blurFilter
      });*/
    }
  }
}
function initializeParallaxForImage(element, parallaxDistance){//(HTMLElement.parallax with a single HTMLElement.parallax__inner child, px for the child to move vertically):void
  var innerElement = element.children[0];

  $(window).bind('scroll resize', function(event){
    onScrollOrResize();
  });
  onScrollOrResize();//Run once to initialize.

  function onScrollOrResize(){
    if(isElementVisible(element)){

      if(isTouchDevice()){//Don't parallax on touch devices.
        p = .5;//Disables the vertigo effect.
        var h = $(innerElement).height();
        $(element).css({height:h-parallaxDistance/2});
        $(innerElement).css({top:-parallaxDistance/2});
        return;
      }

      //Find the current height of the innerElement, and set the container element to be parallaxDistance shorter than it.
      var containerHeight = $(innerElement).height() - parallaxDistance;
      $(element).css({height:containerHeight});

      //Start the parallax effect when the top of the element reaches the bottom of the viewport (0%).
      //End the effect when the bottom of the element reaches the top of the viewport (100%).
      var element_middleY = elementTopViewportY = element.getBoundingClientRect().top + element.offsetHeight/2;
      var element_topY = elementTopViewportY = element.getBoundingClientRect().top + element.offsetHeight;
      var element_bottomY = elementBottomViewportY = element.getBoundingClientRect().top;
      var p = elementPercentScrolledThroughScreen = (window.innerHeight - element_middleY) / window.innerHeight;
      if(p < 0) p = 0;
      if(p > 1) p = 1;
      //console.log(p); if(Math.random() > .7) console.clear();

      var innerElement_yStart = 0;
      var innerElement_yEnd = $(element).height() - $(innerElement).height();
      var y = innerElement_yStart + p * (innerElement_yEnd - innerElement_yStart);
      $(innerElement).css({top:y});

    }
  }
}

function initializeHeaderSocialButtons(){
  var _ = this;

  _.socialMediaButtons = $('.social-media-buttons')[0];
  _.label = $('.social-media-buttons__label')[0];
  _.buttons = $('.social-media-buttons__buttons')[0];
  _.facebookButton = $('.social-media-buttons .facebook')[0];
  _.twitterButton = $('.social-media-buttons .twitter');
  _.googlePlusButton = $('.social-media-buttons .google-plus')[0];
  _.pinterestButton = $('.social-media-buttons .pinterest')[0];
  _.commentButton = $('.social-media-buttons .comment')[0];

  $(_.label).bind('click', function(event){
    if(window.innerWidth <= 860){
      if($(_.socialMediaButtons).hasClass('open')){
        closeSocialMediaButtons();
      }else{
        $(_.socialMediaButtons).addClass('open');
      }
    }
  });
  function closeSocialMediaButtons(){
	  $(_.socialMediaButtons).removeClass('open');
  }
  $(_.facebookButton).attr('href', createFacebookShareURL()).click(facebookButton_onClick);
  $(_.twitterButton).attr('href', createTwitterShareURL()).click(twitterButton_onClick);
  $(_.googlePlusButton).attr('href', createGooglePlusShareURL()).click(googlePlusButton_onClick);
  $(_.pinterestButton).attr('href', createPinterestShareURL()).click(pinterestButton_onClick);
  $(_.commentButton).click(commentButton_onClick);

  function createFacebookShareURL(){
    closeSocialMediaButtons();
    //Documentation at https://developers.facebook.com/docs/reference/plugins/share-links/
    var URL = 'https://www.facebook.com/sharer/sharer.php?'
    +'u='+encodeURI('http://www.rollingstone.com/feature/the-geeks-on-the-frontlines');
    return URL;
  }
  function facebookButton_onClick(event){
    event.preventDefault();
    closeSocialMediaButtons();
    var URL = $(_.facebookButton).attr('href');
    popup(URL, 'facebook-share-dialog', 626, 382);
  }
  function createTwitterShareURL(){
    closeSocialMediaButtons();
    //Documentation at https://dev.twitter.com/docs/intents
    var copy = "The Geeks on the Front Lines: @RollingStone's interactive experience made possible by @HTML5Hub";
    var URLToShare = 'http://rol.st/1cLY8QM';
    var URL = 'https://twitter.com/intent/tweet?'
    +'text='+encodeURI(copy)
    +'&url='+encodeURI(URLToShare);
    return URL;
  }
  function twitterButton_onClick(event){
    closeSocialMediaButtons();
    event.preventDefault();
    var URL = $(_.twitterButton).attr('href');
    popup(URL, 'twitter-share-dialog', 500, 285);
  }
  function createGooglePlusShareURL(){
    closeSocialMediaButtons();
    //Documentation at https://developers.google.com/+/web/share/ and https://developers.google.com/+/web/snippet/
    //Uses the Share Endpoint.
    var URL = 'https://plus.google.com/share?'
    +'url='+encodeURI('http://rol.st/1ejtMXL');
    //+'h1=en-US';
    return URL;
  }
  function googlePlusButton_onClick(event){
    closeSocialMediaButtons();
    event.preventDefault();
    var URL = $(_.googlePlusButton).attr('href');
    popup(URL, 'google-plus-share-dialog', 492, 517);
  }
  function createPinterestShareURL(){
    //Reverse engineered from button generator at http://business.pinterest.com/widget-builder/#do_pin_it_button
    var description = 'The Geeks on the Front Lines';
    var URL = 'http://pinterest.com/pin/create/button/?'
    +'url='+encodeURI('http://rol.st/15HaQdG')
    +'&media='+encodeURI('http://cdn.rollingstone.com/feature/the-geeks-on-the-frontlines/img/rs_600x400.jpg')
    +'&description='+encodeURI(description);
    return URL;
  }
  function pinterestButton_onClick(event){
    closeSocialMediaButtons();
    event.preventDefault();
    var URL = $(_.pinterestButton).attr('href');
    popup(URL, 'pinterest-share-dialog', 750, 336);
  }
  function commentButton_onClick(event){
    closeSocialMediaButtons();
    event.preventDefault();
    var discus = $('#comments')[0];
    var coords = discus.getBoundingClientRect();
    var yPositionToScrollTo = discus.offsetTop + 4955;
    $(window).scrollTop(yPositionToScrollTo);
    $(discus).focus();
  }
  function popup(url, windowName, w, h){//Creates a popup and centers it on the browser window.
    var left = (screen.width/2)-(w/2);
    var top = (screen.height/2)-(h/2);
    var new_left = window.screenX + (((window.outerWidth/2) - (w/2)));
    var new_top = window.screenY + (((window.outerHeight/2) - (w/2)));
    var params = 'width='+w+', height='+h+', top='+new_top+', left='+new_left+', toolbar=no, location=no, directories=no, status=no, menubar=no, scrollbars=no, copyhistory=no';
    return window.open(url, windowName, params);
  }
}







/*****
Class: GlitchyImageModel
Extends: none
Implements: none

Notes:
*****/


//STATIC VARS
GlitchyImageModel.objType = 'GlitchyImageModel';


//CONSTRUCTOR
function GlitchyImageModel(speedTiedToScrolling, subImageModels){//(Boolean, Array of settings objects):GlitchyImageModel
  var _ = this;

  _.objType = GlitchyImageModel.objType;
  _.speedTiedToScrolling = speedTiedToScrolling;//Boolean. If true, then it animates slower when it is near the top or bottom of the page. If true, it always animates at the same speed.
  _.subImageModels = subImageModels;//Array of settings objects. See interface below.

  /*****
    Settings object interface: {
      visibility:{//controls blinking
        percentTimeVisible: int from 0 (always hidden) to 1 (always visible)
        speed: milliseconds that the image is typically visible
        randomness: int from 0 (stable) to 1 (sporadic) that controls how randomly the image blinks.
      },
      //opacity:tbd,
      //movement:tbd
    }
  *****/

  return _;
}


/*****
end GlitchyImageModel
*****/




/*****

Class: GlitchyImageVC
Extends: none
Implements: none

Notes: This class creates an animated glitching image.

Implementation:
1. In HTML, create a div that contains images:
<div id="glitchy-image-1" class="glitchy-image">
    <img src="img/title/blue-overlay.gif"/>
    <img src="img/title/title.png"/>
    <img src="img/title/red-glitch-overlay.gif"/>
</div>
2. In JavaScript, create a GlitchyImageModel, and pass in an array of GlitchySubImageModels which specify the animation properties of each individual image.
3. Create a GlitchyImageVC, and pass in the view (DOMElement with class 'glitchy-image'), and the model.
The GlitchyImage will now animate automatically using the rules and images you've provided. It will not animate if it is offscreen. It animates faster the closer it is to the vertical center of the screen.

*****/


//STATIC VARS
GlitchyImageVC.objType = 'GlitchyImageVC';


//CONSTRUCTOR
function GlitchyImageVC(view, model){//(DOMElement, GlitchyImageModel):GlitchyImageVC
  var _ = this;
  _.objType = GlitchyImageVC.objType;//Allow type checking.
  //AppVC.addController(_, view);
  if(__config.logging) log('new GlitchyImageVC()');

  //SETTINGS
  //_.settings = {};

  //MODEL
  _.id = view.id;
  _.modelType == GlitchyImageModel;
  _.model = model;//GlitchyImageModel

  //VIEW
  _.$view = $view = $(view);
  _.view = view;
  //_.clip = _.$view.find('.clip')[0];
  //_.clip = _.view.getElementByID('clip');
  _.subImagesVCs = [];

  //CONTROLLER
  _.percentDistanceFromVerticalCenterOfScreen = null;

  //INITIALIZE
  var glitchySubImageElements = $view.find('.glitchy-image__sub-image').toArray();
  for(var i in glitchySubImageElements){
    var glitchySubImageElement = glitchySubImageElements[i];
    var subImageModel = _.model.subImageModels[i];
    if(subImageModel) var subImageVC = new GlitchySubImageVC(glitchySubImageElement, subImageModel);
    _.subImagesVCs.push(subImageVC);
  }

}
/*GlitchyImageVC.prototype.updateSpeedBasedOnScrollPosition = function(){
    var _ = this;
    var elementPosition = _.$view.offset();
    var verticalCenterOfElement = elementPosition.top + _.view.offsetHeight/2;
    var centerOfWindow = (window.innerHeight/2);
    var pixelDistanceFromVerticalCenterOfScreen =  (centerOfWindow / verticalCenterOfElement);
    _.percentDistanceFromVerticalCenterOfScreen =  (pixelDistanceFromVerticalCenterOfScreen - 1)/2;
    //var isVisible = (_.percentDistanceFromVerticalCenterOfScreen > -1 && _.percentDistanceFromVerticalCenterOfScreen < 1)
    var isVisible = isElementOnScreen(_.view);
    if(isVisible && !_.isAnimating){
        _.startAnimating();
    }else if(!isVisible && _.isAnimating){
        _.stopAnimating();
    }else{
        //Do nothing.
    }
}*/
GlitchyImageVC.prototype.startAnimating = function(){
  var _ = this;
  if(_.id == 'glitchy-image-9') console.log('GlitchyImageVC.startAnimating() '+_.view.id);
  _.isAnimating = true;

  //Start animating
  for(var i in _.subImagesVCs){
    var subImageVC = _.subImagesVCs[i];
    subImageVC.startAnimating();
  }
}
GlitchyImageVC.prototype.stopAnimating = function(){
  var _ = this;
  if(_.id == 'glitchy-image-9') console.log('GlitchyImageVC.stopAnimating() '+_.view.id);
  _.isAnimating = false;

  //Stop animating
  for(var i in _.subImagesVCs){
    var subImageVC = _.subImagesVCs[i];
    if(subImageVC.isAnimating){
      subImageVC.stopAnimating();
    }
  }
}


/*****
end GlitchyImageVC
*****/




/*****
Class: GlitchySubImageModel
Extends: none
Implements: none

Notes:
*****/


//STATIC VARS
GlitchySubImageModel.objType = 'GlitchySubImageModel';


//CONSTRUCTOR
function GlitchySubImageModel(valuesObject){//(Object with same properties as this model):GlitchySubImageModel
  var _ = this;

  _.objType = GlitchySubImageModel.objType;
  _.visibility = {//controls blinking
    //percentTimeVisible: .03,//int from 0 (always hidden) to 1 (always visible)
    averageDurationVisible: 20,//milliseconds that the image is typically visible
    averageDurationInvisible: 4000,//milliseconds that the image is typically hidden
    randomness: 10,//int from 0 (stable) to infinity (sporadic) that controls how randomly the image blinks
    fadeOutTime: 0,
    fadeInTime: 0
  };
  _.movement = {
    x: 0,//Horizontal distance the image might move left or right.
    y: 0,//Vertical distance the image might move left or right.
    frequency: 0//Percentage of the time that the image moves, from 0 (always in same spot) to 1 (always moves).
  }

  //Transfer values from initialization object to self.
  for(var property in valuesObject){
    _[property] = valuesObject[property];
  }

  return _;
}


/*****
end GlitchyImageModel
*****/




/*****

Class: GlitchyImage_SubImageVC
Extends: none
Implements: none

Notes: This is an individual image inside of a GlitchyImage

Implementation:
1. Pass in a view and a settings objects which specify the animation properties of the image.

*****/


//STATIC VARS
GlitchySubImageVC.objType = 'GlitchyImage_SubImageVC';


//CONSTRUCTOR
function GlitchySubImageVC(view, model){//(<img>Element, GlitchySubImageModel):GlitchySubImageVC
  var _ = this;
  _.objType = GlitchySubImageVC.objType;//Allow type checking.
  if(__config.logging) log('new GlitchySubImageVC()');

  //SETTINGS
  //_.settings = {};

  //MODEL
  _.modelType == GlitchySubImageModel;
  _.model = model;//GlitchySubImageModel

  //VIEW
  _.$view = $view = $(view);
  _.view = view;
  //_.clip = _.$view.find('.clip')[0];
  //_.clip = _.view.getElementByID('clip');

  //CONTROLLER
  _.totalMilliseconds = 0;
  _.millisecondsVisible = 0;
  _.isAnimating = false;

  //VALIDATE MODEL
  //if(!_.model.visibility.percentTimeVisible || _.model.visibility.percentTimeVisible < 0 || _.model.visibility.percentTimeVisible > 1) e.e;//Invalid value;
  if(!_.model.visibility.averageDurationVisible || _.model.visibility.averageDurationVisible < 10) e.e;//Invalid value;
  if(!_.model.visibility.averageDurationInvisible || _.model.visibility.averageDurationInvisible < 1) e.e;//Invalid value;
  if(_.model.visibility.randomness < 1) e.e;//Invalid value;

  //INITIALIZE
  //Wait for a scroll event to start animating this.
  var percentTimeVisible = (_.model.visibility.averageDurationVisible/_.model.visibility.averageDurationInvisible);
  if(percentTimeVisible < 1){
    _.$view.transition({opacity:0, duration:0});//Hide glitches by default.
  }else{
    _.$view.transition({opacity:1, duration:0})//...unless they are supposed to always be visible.
  }
}
GlitchySubImageVC.prototype.startAnimating = function(){
  var _ = this;
  var wasAnimating = _.isAnimating;
  _.isAnimating = true;
  if(!wasAnimating){
      _._blink();
  }
}
GlitchySubImageVC.prototype.stopAnimating = function(){
  var _ = this;
  _.isAnimating = false;
}
GlitchySubImageVC.prototype._blink = function(forceBlink){
  var _ = this;
  var fadeInTime = _.model.visibility.fadeInTime;
  var fadeOutTime = _.model.visibility.fadeOutTime;
  if(!_.isAnimating && !forceBlink){
    _.$view.transition({opacity:0, duration:fadeOutTime, queue:false})//Hide the glitch.
    return;//Kill the animation.
  }

  //Handle visibility and time.
  var isHidden = null;
  var percentTimeVisible = (_.model.visibility.averageDurationVisible/_.model.visibility.averageDurationInvisible);
  percentTimeVisible = percentTimeVisible;
  var percentTimeVisibleSoFar = _.millisecondsVisible/_.totalMilliseconds;
  var duration = null;
  //console.log(percentTimeVisibleSoFar+' : '+_.model.visibility.percentTimeVisible)
  if(percentTimeVisibleSoFar >= percentTimeVisible){//If it has been visible longer than it should be, hide it.
    _.$view.transition({opacity:0, duration:fadeOutTime, queue:false})//Hide the glitch.
    isHidden = true;
    duration = GlitchySubImageVC.getRandomDuration(_.model.visibility.randomness, _.model.visibility.averageDurationInvisible);
    //duration = 1*Math.random()*_.model.visibility.randomness;//If hiding, only hide a split second before checking again. This encourages the jittering effect, rather than a blinking.
    //console.log('Hide '+_.view.classList[0]+' for '+duration+' milliseconds.');
  }else{//Otherwise show it.
    _.$view.transition({opacity:1, duration:fadeInTime, queue:false})//Hide the glitch.
    isHidden = false;
    duration = GlitchySubImageVC.getRandomDuration(_.model.visibility.randomness, _.model.visibility.averageDurationVisible);//If showing, show for a longer duration before checking again.
    _.millisecondsVisible += duration;
    //console.log('Show '+_.view.classList[0]+' for '+duration+' milliseconds.');
  }
  _.totalMilliseconds += duration;

  //Handle movement
  if(_.model.movement.frequency > Math.random()){//Only move the image sometimes, based on the movement frequency percentage.
    var xTranslation = _.model.movement.x * Math.random() * getPlusOrMinus();
    var yTranslation = _.model.movement.y * Math.random() * getPlusOrMinus();
    _.$view.css({left:xTranslation, top:yTranslation});
  }

  setTimeout(function(){
    _._blink();
  }, duration);
}
GlitchySubImageVC.getRandomDuration = function(randomness, normalDuration){
  var maxVariation = 10;
  var plusOrMinus = getPlusOrMinus();
  var randomMilliseconds = null;
  if(plusOrMinus > 0){
    randomMilliseconds = Math.random() * randomness * normalDuration*plusOrMinus;//Lengthen the duration.
  }else{
    randomMilliseconds = normalDuration - Math.random() * normalDuration;//Shorten the duration, but not below 0.
    if(randomMilliseconds < 1) randomMilliseconds = 1;
  }
  var duration = normalDuration + randomMilliseconds;
  return duration;
}



/*****

end GlitchySubImageVC

*****/

function isElementVisible(element){//(element):Boolean
	var coords = element.getBoundingClientRect();
	var isBelowView = (coords.top > window.innerHeight);
	var isAboveView = (coords.top + element.offsetHeight) < 0;
	var isElementOnScreen = !(isBelowView || isAboveView);
	var isVisible2 = $(element).is(":visible");
	var value = (isElementOnScreen && isVisible2);
	return value;
}


function initializeGlitchyImages(){
  var _ = this;

  //Initialize Glitchy images
  _.glitchyImageVCs = [];




  //Create GlitchyImages with default settings.
  var glitchyImageElements = $('.glitchy-image').toArray();
  for(var i in glitchyImageElements){
    var glitchyImageElement = glitchyImageElements[i];
    if(glitchyImageElement.id == 'glitchy-image-1'){
      //GlitchyImage1 has already been initialized.
      var glitchyImage1Model = new GlitchyImageModel(true,
      [
        new GlitchySubImageModel({//Red
          visibility: {//controls blinking
            averageDurationVisible: 30,//Milliseconds that the image is typically visible.
            averageDurationInvisible: 90000,//Milliseconds that the image is typically invisible.
            randomness: 1//Integer from 1 (clock-like) to infinity (sporadic) that controls how randomly the image blinks.
          },
          movement: {
            x: 100,//Horizontal distance the image might move left or right.
            y: 100,//Vertical distance the image might move left or right.
            frequency: .1//Percentage of the time that the image moves, from 0 (always in same spot) to 1 (always moves).
          }
        }),
        new GlitchySubImageModel({
          visibility: {
            averageDurationVisible: 1000,
            averageDurationInvisible: 4000,
            randomness: 1
          },
          movement:{x:500, y:300, frequency:.7}
        }),
        new GlitchySubImageModel({
          visibility: {
            averageDurationVisible: 500,
            averageDurationInvisible: 200,
            randomness: 1
          },
          movement: {x: 0, y: 0, frequency: .1}
        })
      ]);
      var glitchyImage1 = $('#glitchy-image-1')[0];
      var glitchyImage1VC = new GlitchyImageVC(glitchyImage1, glitchyImage1Model);
      _.glitchyImageVCs.push(glitchyImage1VC);

    }else if(glitchyImageElement.id == 'glitchy-image-4'){//Humperdink
      var glitchyImageModel = new GlitchyImageModel(true, [
        new GlitchySubImageModel({
          visibility: {
            averageDurationVisible: 50,
            averageDurationInvisible: 400
          },
          movement:{x:0, y:0, frequency:.7}
        })
      ]);
      var glitchyImageVC = new GlitchyImageVC(glitchyImageElement, glitchyImageModel);
      _.glitchyImageVCs.push(glitchyImageVC);


    }else if(
      glitchyImageElement.id == 'glitchy-image-2' ||
      glitchyImageElement.id == 'glitchy-image-5' ||
      glitchyImageElement.id == 'glitchy-image-9'
    ){
      //Don't initialize these. Just set them to be always visible.
      $(glitchyImageElement).find('img').css({opacity:1});

    }else if(
      glitchyImageElement.id == 'glitchy-image-6' ||
      glitchyImageElement.id == 'glitchy-image-9'//yellow on red
    ){
      var aaa = new GlitchySubImageModel({
        visibility:{
          averageDurationVisible: 1000,
          averageDurationInvisible: 200,
          randomness: 10,
          fadeOutTime: 500,
          fadeInTime: 500
        },
        movement:{
          x:0,
          y:0,
          frequency:.7
        }
      });
      var glitchyImageModel = new GlitchyImageModel(true, [aaa,aaa,aaa]);
      var glitchyImageVC = new GlitchyImageVC(glitchyImageElement, glitchyImageModel);
      _.glitchyImageVCs.push(glitchyImageVC);


    }else{
      var aaa = new GlitchySubImageModel({
        visibility:{
          averageDurationVisible: 20,
          averageDurationInvisible: 4000,
          randomness: 10,
          fadeOutTime: 0,
          fadeInTime: 0
        },
        movement:{
          x:0,
          y:0,
          frequency:.7
        }
      });
      var glitchyImageModel = new GlitchyImageModel(true, [aaa,aaa,aaa]);
      var glitchyImageVC = new GlitchyImageVC(glitchyImageElement, glitchyImageModel);
      _.glitchyImageVCs.push(glitchyImageVC);
    }
  }

  //Only animate glitches while the user is scrolling.
  _.scrollEventCounter = 0;
  $(window).bind('scroll', function(event){//When the user scrolls...
    /*var scrollCounter = document.getElementById('scrollCounter');
    if(!scrollCounter) $('body').append('<div id="scrollCounter" style="background:blue;padding:10px;position:fixed;top:0;left:0;z-index:38463;color:white;"></div>');
    scrollCounter = document.getElementById('scrollCounter');
    if(!window.scrollCount) window.scrollCount = 0;
    window.scrollCount++;
    scrollCounter.innerHTML = window.scrollCount;*/

	//Track the number of scroll events so we know when
	_.scrollEventCounter++;

    //Start animating any GlitchyImages
    for(var i in _.glitchyImageVCs){
      var glitchyImageVC = _.glitchyImageVCs[i];
      if(isElementVisible(glitchyImageVC.view) && !glitchyImageVC.isAnimating){//If they are visible, and not already animating.
        glitchyImageVC.startAnimating();
      }
    }

    //Then after a moment, stop animating them.
    setTimeout(function(){
    	_.scrollEventCounter--;
    	if(_.scrollEventCounter == 0){
        for(var i in _.glitchyImageVCs){
          var glitchyImageVC = _.glitchyImageVCs[i];
          if(glitchyImageVC.isAnimating){
            glitchyImageVC.stopAnimating();
          }
        }
      }
    }, 50)

  });
  $(window).bind('touchstart', function(){
    $('.glitchy-image').addClass('on');
  });
  $(window).bind('touchend', function(){
    $('.glitchy-image').removeClass('on');
  });

  //Make the Jayson Street hallway lights flicker all the time, on a timer (only if visible on screen).
  var glitchyImage13VC = null;
  for(var i in _.glitchyImageVCs){
    var glitchyImageVC = _.glitchyImageVCs[i];
    if(glitchyImageVC.id == 'glitchy-image-13'){
      glitchyImage13VC = glitchyImageVC;
      break;
    }
  }
  glitchLights();
  function glitchLights(){
    if(isElementVisible(glitchyImageVC.view)){
      glitchyImage13VC.subImagesVCs[0]._blink(true);
    }
    var delay = Math.random()*200;//The delay is anywhere from 0-2 seconds.
    setTimeout(glitchLights, delay);
  }
}

function getPlusOrMinus(){
  return Math.random() < 0.5 ? -1 : 1;
}

function isTouchDevice(){//via http://stackoverflow.com/questions/4817029/whats-the-best-way-to-detect-a-touch-screen-device-using-javascript
	return (/iPhone|iPad|iPod/i.test(navigator.userAgent));
}

(function() {
  var $doc, $introSequence, $introVideo, $progressBar, $scrollIndicator, $videoObject, $win, browserDimensions, calculateScroll, contentTop, currentIndex, currentScrollPosition, fullHeight, handleScroll, imageSeqLoader, imgDir, initialize, introFrames, isMobile, isTouch, loadVideo, loaded, progress, render, scaleMobileIntro, scaleVideo, scrollHeight, watchScroll, windowHeight;

  $doc = null;

  $win = null;

  $introVideo = null;

  $introSequence = null;

  $videoObject = null;

  $progressBar = null;

  $scrollIndicator = null;

  windowHeight = 0;

  fullHeight = 0;

  scrollHeight = 0;

  contentTop = 0;

  currentIndex = 0;

  imgDir = null;

  currentScrollPosition = 0;

  calculateScroll = function() {
    contentTop = parseInt($('.site-wrapper').css('padding-top'));
    windowHeight = $win.height();
    return scrollHeight = contentTop - windowHeight;
  };

  isMobile = function() {
    return $('html').hasClass('mobile');
  };

  isTouch = function() {
    return $('html').hasClass('touch');
  };

  browserDimensions = function() {
    var height, width;
    width = $win.width();
    height = $win.height();
    $('html').attr('data-width', width);
    return $('html').attr('data-height', height);
  };

  initialize = function() {
    $doc = $('document');
    $win = $(window);
    browserDimensions();
    $progressBar = $('.progress');
    $introSequence = $('.js-intro-sequence');
    if (!isMobile()) {
      $('.mobile-intro').remove();
      $('html').addClass('no-scroll');
      scaleVideo();
      $scrollIndicator = $('.scroll-indicator');
      return loadVideo();
    } else {
      scaleMobileIntro();
      $progressBar.remove();
      $('.preloader').remove();
      return $('.js-intro-wrapper').remove();
    }
  };

  loadVideo = function() {
    $introVideo = $('#intro-video');
    if ($('html').hasClass('mobile')) {
      return $('.js-video-tag').remove();
    }
  };

  handleScroll = function() {
    return currentScrollPosition = $(window).scrollTop() / scrollHeight;
  };

  introFrames = function() {
    if (currentScrollPosition > 0) {
      $scrollIndicator.hide();
      if (!isMobile()) {
        $introVideo.hide();
      }
    } else {
      $scrollIndicator.show();
      if (!isMobile()) {
        $introVideo.show();
      }
    }
    if (currentScrollPosition > 1) {
      return $('.js-intro-wrapper').hide();
    } else {
      return $('.js-intro-wrapper').show();
    }
  };

  render = function(position) {
    var img, index, nearestIndex;
    introFrames();
    if (currentScrollPosition < 1) {
      index = Math.round(currentScrollPosition * (imageSeqLoader.length - 1));
      img = imageSeqLoader.getNearest(index);
      nearestIndex = imageSeqLoader.nearestIndex;
      if (!!img) {
        if (nearestIndex !== currentIndex) {
          currentIndex = nearestIndex;
          return $('.js-intro-sequence').attr('src', img.src);
        }
      }
    }
  };

  loaded = function() {
    return $progressBar.fadeOut(200).remove();
  };

  progress = function() {
    var preLoaded;
    preLoaded = Math.floor(imageSeqLoader.getLoadProgress() * 100);
    $progressBar.find('.progress__bar').width(preLoaded + "%");
    if (preLoaded >= 50) {
      $('.preloader').fadeOut(200).remove();
      return $('html').removeClass('no-scroll');
    }
  };

  imageSeqLoader = new ProgressiveImageSequence("http://cdn.rollingstone.com/feature/the-geeks-on-the-frontlines/media/sequence/glitch/m/glitch_{index}.jpg", 329, {
    indexSize: 3,
    onProgress: progress,
    onComplete: loaded,
    stopAt: 6
  });

  scaleVideo = function() {
    var $height, $newHeight, $newWidth, $scale, $vidHeight, $vidWidth, $video, $width, $xScale, $yScale;
    $win = $(window);
    $video = $('.full-screen-video-wrapper');
    if (isMobile()) {
      $width = window.innerWidth;
      $height = window.innerHeight;
    } else {
      $width = $win.width();
      $height = $win.height();
    }
    $vidWidth = 704;
    $vidHeight = 396;
    $xScale = $width / $vidWidth;
    $yScale = $height / $vidHeight;
    if ($xScale > $yScale) {
      $scale = $xScale;
    } else {
      $scale = $yScale;
    }
    $newWidth = $vidWidth * $scale;
    $newHeight = $vidHeight * $scale;
    return $video.css({
      width: Math.ceil($newWidth),
      height: Math.ceil($newHeight),
      'margin-top': Math.floor(($newHeight / 2) * -1),
      'margin-left': Math.floor(($newWidth / 2) * -1)
    });
  };

  scaleMobileIntro = function() {
    windowHeight = $('html').attr('data-height');
    return $('.mobile-intro').css('height', windowHeight);
  };

  $(window).resize(function() {
    if (!isMobile()) {
      browserDimensions();
      return scaleVideo();
    } else {
      return scaleMobileIntro();
    }
  });

  watchScroll = function() {
    render(currentScrollPosition);
    return requestAnimFrame(watchScroll);
  };

  $(function() {
    var loadCounterForIE;
    initialize();
    if (!isMobile()) {
      calculateScroll();
      loadCounterForIE = 0;
      imageSeqLoader.loadPosition(currentScrollPosition, function() {
        loadCounterForIE++;
        if (loadCounterForIE === 1) {
          render(currentScrollPosition);
          imageSeqLoader.load();
          imageSeqLoader.load();
          imageSeqLoader.load();
          return imageSeqLoader.load();
        }
      });
      $win.on('scroll', function() {
        return handleScroll();
      });
      return watchScroll();
    }
  });

}).call(this);

/*!
 *  Echo
 *  @version 1.1.0
 *  @author Todd Motto http://toddmotto.com
 *  Project: https://github.com/toddmotto/echo
 *
 *  Raw JavaScript lazy-loading images with HTML5 data-* attributes.
 *  Copyright 2013. MIT licensed.
 */
window.echo = (function (window, document, undefined) {

  'use strict';

  /*
   * Constructor function
   */
  var Echo = function (elem) {
    this.elem = elem;
  };

  /*
   * Images for echoing
   */
  var echoStore = [];

  /*
   * Element in viewport logic
   */
  var scrolledIntoView = function (element) {
    var coords = element.getBoundingClientRect();
    return ((coords.top >= 0 && coords.left >= 0 && coords.top) <= (window.innerHeight || document.documentElement.clientHeight) + 1000);
  };

  /*
   * Changing src attr logic
   */
  var echoSrc = function (img, callback) {
    img.src = img.getAttribute('data-echo');
    if (callback) {
      callback();
    }
  };

  /*
   * Remove loaded item from array
   */
  var removeEcho = function (element, index) {
    if (echoStore.indexOf(element) !== -1) {
      echoStore.splice(index, 1);
    }
  };

  /*
   * Echo the images and callbacks
   */
  var echoImages = function () {
    for (var i = 0; i < echoStore.length; i++) {
      var self = echoStore[i];
      if (scrolledIntoView(self)) {
        echoSrc(self, removeEcho(self, i));
      }
    }
  };

  /*
   * Prototypal setup
   */
  Echo.prototype = {
    init : function () {
      echoStore.push(this.elem);
    }
  };

  /*
   * Initiate the plugin
   */
  var lazyImgs = document.querySelectorAll('img[data-echo]');
  for (var i = 0; i < lazyImgs.length; i++) {
    new Echo(lazyImgs[i]).init();
  }

  /*
   * Bind the events
   */
  if (document.addEventListener) {
    document.addEventListener('DOMContentLoaded', echoImages, false);
  } else {
    window.onload = echoImages;
  }
  window.onscroll = echoImages;

})(window, document);